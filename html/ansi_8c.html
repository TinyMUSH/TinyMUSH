<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TinyMUSH: src/netmush/ansi.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">TinyMUSH<span id="projectnumber">&#160;3.3</span>
   </div>
   <div id="projectbrief">TinyMUSH Server</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_d49c5bdcdc946239a893bf2d58085e26.html">netmush</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">ansi.c File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>ANSI terminal control helpers and telnet negotiation support.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;config.h&quot;</code><br />
<code>#include &quot;<a class="el" href="constants_8h_source.html">constants.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="typedefs_8h_source.html">typedefs.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="macros_8h_source.html">macros.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="externs_8h_source.html">externs.h</a>&quot;</code><br />
<code>#include &quot;prototypes.h&quot;</code><br />
<code>#include &quot;ansi.h&quot;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;ctype.h&gt;</code><br />
<code>#include &lt;math.h&gt;</code><br />
<code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &lt;strings.h&gt;</code><br />
<code>#include &lt;errno.h&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for ansi.c:</div>
<div class="dyncontent">
<div class="center"><img src="ansi_8c__incl.png" border="0" usemap="#asrc_2netmush_2ansi_8c" alt=""/></div>
<map name="asrc_2netmush_2ansi_8c" id="asrc_2netmush_2ansi_8c">
<area shape="rect" title="ANSI terminal control helpers and telnet negotiation support." alt="" coords="458,5,589,31"/>
<area shape="rect" title=" " alt="" coords="5,79,71,105"/>
<area shape="poly" title=" " alt="" coords="458,29,293,48,86,81,85,76,292,43,457,23"/>
<area shape="rect" href="constants_8h.html" title="Global numeric and string constants for flags, limits, and parser tokens." alt="" coords="95,79,184,105"/>
<area shape="poly" title=" " alt="" coords="458,34,199,82,198,77,457,29"/>
<area shape="rect" href="typedefs_8h.html" title="Core typedefs for dbrefs, flags, buffers, and engine data structures." alt="" coords="388,153,469,178"/>
<area shape="poly" title=" " alt="" coords="479,34,443,52,427,65,415,80,410,94,410,108,418,138,412,139,404,109,405,93,410,78,424,61,440,47,477,29"/>
<area shape="rect" title=" " alt="" coords="213,226,287,252"/>
<area shape="poly" title=" " alt="" coords="480,34,427,53,373,81,332,113,299,154,279,184,264,214,259,211,275,182,295,151,328,110,370,77,425,48,478,29"/>
<area shape="rect" href="macros_8h.html" title="Engine&#45;wide macros for memory tracking, flag checks, logging, and utilities." alt="" coords="540,79,614,105"/>
<area shape="poly" title=" " alt="" coords="534,30,561,65,556,68,530,33"/>
<area shape="rect" href="externs_8h.html" title="Shared extern declarations and globals used across the game engine." alt="" coords="637,79,711,105"/>
<area shape="poly" title=" " alt="" coords="550,29,636,70,633,74,548,34"/>
<area shape="rect" href="prototypes_8h_source.html" title=" " alt="" coords="424,79,516,105"/>
<area shape="poly" title=" " alt="" coords="517,33,490,68,486,65,512,30"/>
<area shape="rect" href="ansi_8h_source.html" title=" " alt="" coords="309,153,364,178"/>
<area shape="poly" title=" " alt="" coords="490,34,447,53,404,81,375,111,353,141,349,138,371,107,400,77,444,49,487,29"/>
<area shape="rect" title=" " alt="" coords="122,226,189,252"/>
<area shape="poly" title=" " alt="" coords="462,34,398,53,333,81,285,113,242,150,177,217,173,213,238,146,282,109,330,77,396,48,460,29"/>
<area shape="rect" title=" " alt="" coords="735,79,797,105"/>
<area shape="poly" title=" " alt="" coords="565,29,721,74,719,80,564,34"/>
<area shape="rect" title=" " alt="" coords="821,79,882,105"/>
<area shape="poly" title=" " alt="" coords="587,29,807,76,806,81,586,34"/>
<area shape="rect" title=" " alt="" coords="905,79,968,105"/>
<area shape="poly" title=" " alt="" coords="590,25,725,45,890,76,889,81,724,51,589,31"/>
<area shape="rect" title=" " alt="" coords="992,79,1062,105"/>
<area shape="poly" title=" " alt="" coords="590,23,762,43,977,76,976,81,761,48,589,28"/>
<area shape="rect" title=" " alt="" coords="1086,79,1147,105"/>
<area shape="poly" title=" " alt="" coords="590,21,801,38,934,54,1072,76,1071,82,933,60,800,44,589,26"/>
<area shape="rect" title=" " alt="" coords="112,153,167,178"/>
<area shape="poly" title=" " alt="" coords="142,105,142,137,137,137,137,105"/>
<area shape="rect" title=" " alt="" coords="310,226,374,252"/>
<area shape="poly" title=" " alt="" coords="416,181,370,218,366,214,412,177"/>
<area shape="rect" title=" " alt="" coords="478,226,537,252"/>
<area shape="poly" title=" " alt="" coords="444,177,485,214,481,218,440,181"/>
<area shape="poly" title=" " alt="" coords="399,181,295,223,294,218,397,176"/>
<area shape="rect" title=" " alt="" coords="398,226,454,252"/>
<area shape="poly" title=" " alt="" coords="431,179,430,211,424,211,426,178"/>
<area shape="rect" title=" " alt="" coords="560,226,641,252"/>
<area shape="poly" title=" " alt="" coords="459,176,558,218,556,222,457,181"/>
<area shape="rect" title=" " alt="" coords="665,226,750,252"/>
<area shape="poly" title=" " alt="" coords="470,175,651,221,649,226,469,180"/>
<area shape="poly" title=" " alt="" coords="465,106,446,141,441,138,461,104"/>
<area shape="poly" title=" " alt="" coords="476,104,503,211,498,212,470,106"/>
<area shape="poly" title=" " alt="" coords="483,103,582,213,578,217,479,107"/>
<area shape="poly" title=" " alt="" coords="491,103,676,216,674,220,488,108"/>
<area shape="rect" title=" " alt="" coords="644,153,706,178"/>
<area shape="poly" title=" " alt="" coords="506,103,630,146,629,151,504,108"/>
<area shape="rect" title=" " alt="" coords="731,153,798,178"/>
<area shape="poly" title=" " alt="" coords="517,102,717,150,715,155,516,107"/>
<area shape="poly" title=" " alt="" coords="449,108,374,147,372,143,446,103"/>
<area shape="poly" title=" " alt="" coords="340,178,343,211,337,211,335,179"/>
<area shape="poly" title=" " alt="" coords="324,181,278,218,274,214,320,177"/>
<area shape="poly" title=" " alt="" coords="309,180,201,223,199,218,307,175"/>
</map>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLevelAnsiStreamContext.html">LevelAnsiStreamContext</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a3658ff42f9d25c50836c7aeacb780b8f" id="r_a3658ff42f9d25c50836c7aeacb780b8f"><td class="memItemLeft" align="right" valign="top"><a id="a3658ff42f9d25c50836c7aeacb780b8f" name="a3658ff42f9d25c50836c7aeacb780b8f"></a>
typedef struct LevelAnsiStreamContext&#160;</td><td class="memItemRight" valign="bottom"><b>LevelAnsiStreamContext</b></td></tr>
<tr class="separator:a3658ff42f9d25c50836c7aeacb780b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aedbc240c83b027a81456f399edee9606" id="r_aedbc240c83b027a81456f399edee9606"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structColorCIELab.html">ColorCIELab</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aedbc240c83b027a81456f399edee9606">ansi_rgb_to_cielab</a> (<a class="el" href="structColorRGB.html">ColorRGB</a> color)</td></tr>
<tr class="memdesc:aedbc240c83b027a81456f399edee9606"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an RGB color to CIELAB color space.  <br /></td></tr>
<tr class="separator:aedbc240c83b027a81456f399edee9606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18b1d3b66e84fb99814b4bf240f7ba42" id="r_a18b1d3b66e84fb99814b4bf240f7ba42"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a18b1d3b66e84fb99814b4bf240f7ba42">ansi_ciede2000</a> (<a class="el" href="structColorCIELab.html">ColorCIELab</a> lab1, <a class="el" href="structColorCIELab.html">ColorCIELab</a> lab2)</td></tr>
<tr class="memdesc:a18b1d3b66e84fb99814b4bf240f7ba42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the CIEDE2000 distance between two CIELAB colors.  <br /></td></tr>
<tr class="separator:a18b1d3b66e84fb99814b4bf240f7ba42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a925d6c1ab43d953c312a7203a9658cef" id="r_a925d6c1ab43d953c312a7203a9658cef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structColorEntry.html">ColorEntry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a925d6c1ab43d953c312a7203a9658cef">ansi_find_closest_color_with_lab</a> (<a class="el" href="structColorCIELab.html">ColorCIELab</a> lab, ColorType type)</td></tr>
<tr class="memdesc:a925d6c1ab43d953c312a7203a9658cef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the closest ANSI or XTerm color to a given CIELAB color.  <br /></td></tr>
<tr class="separator:a925d6c1ab43d953c312a7203a9658cef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72b1530ed14defc2cef739cfddecf5d4" id="r_a72b1530ed14defc2cef739cfddecf5d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a72b1530ed14defc2cef739cfddecf5d4">ansi_get_color_from_rgb</a> (<a class="el" href="structColorState.html">ColorState</a> *color, <a class="el" href="structColorRGB.html">ColorRGB</a> rgb, bool is_background)</td></tr>
<tr class="memdesc:a72b1530ed14defc2cef739cfddecf5d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the foreground or background color from an RGB color.  <br /></td></tr>
<tr class="separator:a72b1530ed14defc2cef739cfddecf5d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e70a884881eb06af93d5ba2a0418c78" id="r_a0e70a884881eb06af93d5ba2a0418c78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e70a884881eb06af93d5ba2a0418c78">ansi_get_color_from_index</a> (<a class="el" href="structColorState.html">ColorState</a> *color, int index, bool is_background)</td></tr>
<tr class="memdesc:a0e70a884881eb06af93d5ba2a0418c78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the foreground or background color from an XTerm index.  <br /></td></tr>
<tr class="separator:a0e70a884881eb06af93d5ba2a0418c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bdc82d815125f5a5a354bee287ddd65" id="r_a3bdc82d815125f5a5a354bee287ddd65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3bdc82d815125f5a5a354bee287ddd65">ansi_get_color_from_name</a> (<a class="el" href="structColorState.html">ColorState</a> *color, const char *name, bool is_background)</td></tr>
<tr class="memdesc:a3bdc82d815125f5a5a354bee287ddd65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the foreground or background color from a color name.  <br /></td></tr>
<tr class="separator:a3bdc82d815125f5a5a354bee287ddd65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d5c4c199abf39e759cbf884c7980e2b" id="r_a6d5c4c199abf39e759cbf884c7980e2b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d5c4c199abf39e759cbf884c7980e2b">ansi_get_color_from_text</a> (<a class="el" href="structColorState.html">ColorState</a> *color, char *text, bool is_background)</td></tr>
<tr class="memdesc:a6d5c4c199abf39e759cbf884c7980e2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a hexadecimal or decimal string to set an RGB color.  <br /></td></tr>
<tr class="separator:a6d5c4c199abf39e759cbf884c7980e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a577ecea9667560f8636243f0521fbc70" id="r_a577ecea9667560f8636243f0521fbc70"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a577ecea9667560f8636243f0521fbc70">ansi_parse_color_from_string</a> (<a class="el" href="structColorState.html">ColorState</a> *color, const char *color_str, bool is_background)</td></tr>
<tr class="memdesc:a577ecea9667560f8636243f0521fbc70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a complex color string and sets the corresponding color.  <br /></td></tr>
<tr class="separator:a577ecea9667560f8636243f0521fbc70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b21f23eddfbccf6797676310288e2c" id="r_a43b21f23eddfbccf6797676310288e2c"><td class="memItemLeft" align="right" valign="top">ColorStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a43b21f23eddfbccf6797676310288e2c">to_ansi_escape_sequence</a> (char *buffer, size_t buffer_size, size_t *offset, <a class="el" href="structColorState.html">ColorState</a> *to, ColorType type)</td></tr>
<tr class="memdesc:a43b21f23eddfbccf6797676310288e2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates an ANSI escape sequence from the color state.  <br /></td></tr>
<tr class="separator:a43b21f23eddfbccf6797676310288e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cebcc38b9c124e68d8a327fa8490a73" id="r_a9cebcc38b9c124e68d8a327fa8490a73"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9cebcc38b9c124e68d8a327fa8490a73">ansi_transition_colorstate</a> (const <a class="el" href="structColorState.html">ColorState</a> from, const <a class="el" href="structColorState.html">ColorState</a> to, ColorType type, bool no_default_bg)</td></tr>
<tr class="memdesc:a9cebcc38b9c124e68d8a327fa8490a73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build an ANSI escape sequence to transition between two <a class="el" href="structColorState.html" title="Complete text formatting state.">ColorState</a> values.  <br /></td></tr>
<tr class="separator:a9cebcc38b9c124e68d8a327fa8490a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18b234e1abc49099a86ddf807cd5b71b" id="r_a18b234e1abc49099a86ddf807cd5b71b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a18b234e1abc49099a86ddf807cd5b71b">ansi_parse_embedded_sequences</a> (const char *input, <a class="el" href="structColorSequence.html">ColorSequence</a> *sequences)</td></tr>
<tr class="memdesc:a18b234e1abc49099a86ddf807cd5b71b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses embedded ANSI sequences in a string marked with 'x<code>'. </code> <br /></td></tr>
<tr class="separator:a18b234e1abc49099a86ddf807cd5b71b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10019119f7dc128e9848f4e04b6ce4f1" id="r_a10019119f7dc128e9848f4e04b6ce4f1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a10019119f7dc128e9848f4e04b6ce4f1">ansi_parse_single_x_code</a> (char **input_ptr, <a class="el" href="structColorState.html">ColorState</a> *color_out, bool *current_highlight)</td></tr>
<tr class="memdesc:a10019119f7dc128e9848f4e04b6ce4f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a single x color code from the current position.  <br /></td></tr>
<tr class="separator:a10019119f7dc128e9848f4e04b6ce4f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4447edd53423a6ecc0a63320eafd3279" id="r_a4447edd53423a6ecc0a63320eafd3279"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4447edd53423a6ecc0a63320eafd3279">ansi_parse_ansi_to_sequences</a> (const char *input, <a class="el" href="structColorSequence.html">ColorSequence</a> *sequences)</td></tr>
<tr class="memdesc:a4447edd53423a6ecc0a63320eafd3279"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a string with ANSI escape sequences and converts it to a <a class="el" href="structColorSequence.html" title="Parsed color sequence information.">ColorSequence</a>.  <br /></td></tr>
<tr class="separator:a4447edd53423a6ecc0a63320eafd3279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94d0aa911d32eef8396b50b0680588e8" id="r_a94d0aa911d32eef8396b50b0680588e8"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94d0aa911d32eef8396b50b0680588e8">color_state_to_mush_code</a> (const <a class="el" href="structColorState.html">ColorState</a> *color)</td></tr>
<tr class="memdesc:a94d0aa911d32eef8396b50b0680588e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a mushcode string from a <a class="el" href="structColorState.html" title="Complete text formatting state.">ColorState</a>.  <br /></td></tr>
<tr class="separator:a94d0aa911d32eef8396b50b0680588e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1de5e3964b9254739c4d69c548ff327" id="r_af1de5e3964b9254739c4d69c548ff327"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1de5e3964b9254739c4d69c548ff327">color_state_to_letters</a> (const <a class="el" href="structColorState.html">ColorState</a> *color)</td></tr>
<tr class="memdesc:af1de5e3964b9254739c4d69c548ff327"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a letter code string from a <a class="el" href="structColorState.html" title="Complete text formatting state.">ColorState</a>.  <br /></td></tr>
<tr class="separator:af1de5e3964b9254739c4d69c548ff327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f2dfc1be1e8498eede545d0f5f3da3d" id="r_a6f2dfc1be1e8498eede545d0f5f3da3d"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f2dfc1be1e8498eede545d0f5f3da3d">color_state_to_escape</a> (const <a class="el" href="structColorState.html">ColorState</a> *color, ColorType type)</td></tr>
<tr class="memdesc:a6f2dfc1be1e8498eede545d0f5f3da3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a <a class="el" href="structColorState.html" title="Complete text formatting state.">ColorState</a> to an ANSI escape sequence string.  <br /></td></tr>
<tr class="separator:a6f2dfc1be1e8498eede545d0f5f3da3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca24d3e613ed38abb9ee92470dc618ea" id="r_aca24d3e613ed38abb9ee92470dc618ea"><td class="memItemLeft" align="right" valign="top"><a id="aca24d3e613ed38abb9ee92470dc618ea" name="aca24d3e613ed38abb9ee92470dc618ea"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>xsafe_ansi_normal</b> (char *buff, char **bufc)</td></tr>
<tr class="memdesc:aca24d3e613ed38abb9ee92470dc618ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safely append an ANSI reset using the <a class="el" href="structColorState.html" title="Complete text formatting state.">ColorState</a> pipeline. <br /></td></tr>
<tr class="separator:aca24d3e613ed38abb9ee92470dc618ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a287dfc7f24bd306f6a627a9cec89d06e" id="r_a287dfc7f24bd306f6a627a9cec89d06e"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a287dfc7f24bd306f6a627a9cec89d06e">ansi_parse_x_to_sequence</a> (char **ptr, ColorType type)</td></tr>
<tr class="memdesc:a287dfc7f24bd306f6a627a9cec89d06e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a x color code and generates the corresponding ANSI escape sequence.  <br /></td></tr>
<tr class="separator:a287dfc7f24bd306f6a627a9cec89d06e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10dfbb563532866525801626d470654a" id="r_a10dfbb563532866525801626d470654a"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a10dfbb563532866525801626d470654a">ansi_char_to_sequence</a> (int ch)</td></tr>
<tr class="memdesc:a10dfbb563532866525801626d470654a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert ansi character code (x?) to ansi sequence. Replacement for the ansiChar lookup table using colorDefinitions.  <br /></td></tr>
<tr class="separator:a10dfbb563532866525801626d470654a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a485875ebf5bbab9e634e0f1420b6251b" id="r_a485875ebf5bbab9e634e0f1420b6251b"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a485875ebf5bbab9e634e0f1420b6251b">ansi_char_bright_to_sequence</a> (int ch)</td></tr>
<tr class="memdesc:a485875ebf5bbab9e634e0f1420b6251b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert ansi character code (x? uppercase) to bright ansi sequence. Replacement for the ansiChar_Bright lookup table using colorDefinitions.  <br /></td></tr>
<tr class="separator:a485875ebf5bbab9e634e0f1420b6251b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d695364d336b94905b4f2089ef1efc5" id="r_a0d695364d336b94905b4f2089ef1efc5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d695364d336b94905b4f2089ef1efc5">ansi_char_to_num</a> (int ch)</td></tr>
<tr class="memdesc:a0d695364d336b94905b4f2089ef1efc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert ansi character code to numeric values. Replacement for the ansiNum lookup table using colorDefinitions.  <br /></td></tr>
<tr class="separator:a0d695364d336b94905b4f2089ef1efc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3abb17b5cce10d3ef76e970c6f91e9c" id="r_aa3abb17b5cce10d3ef76e970c6f91e9c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa3abb17b5cce10d3ef76e970c6f91e9c">mushcode_to_sgr</a> (int ch)</td></tr>
<tr class="memdesc:aa3abb17b5cce10d3ef76e970c6f91e9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a mushcode color letter to an ANSI SGR number (30-37 / 40-47).  <br /></td></tr>
<tr class="separator:aa3abb17b5cce10d3ef76e970c6f91e9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58b519c2fe1d69b8e764a703bc47f390" id="r_a58b519c2fe1d69b8e764a703bc47f390"><td class="memItemLeft" align="right" valign="top"><a id="a58b519c2fe1d69b8e764a703bc47f390" name="a58b519c2fe1d69b8e764a703bc47f390"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>ansi_apply_sequence</b> (const char **ptr, <a class="el" href="structColorState.html">ColorState</a> *state)</td></tr>
<tr class="separator:a58b519c2fe1d69b8e764a703bc47f390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e5d2f2d347f09a618a3e8685120cfb3" id="r_a7e5d2f2d347f09a618a3e8685120cfb3"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e5d2f2d347f09a618a3e8685120cfb3">translate_string_ansi</a> (const char *str, int type)</td></tr>
<tr class="memdesc:a7e5d2f2d347f09a618a3e8685120cfb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert ANSI escape sequences to mushcode or strip ANSI codes using the new ANSI API.  <br /></td></tr>
<tr class="separator:a7e5d2f2d347f09a618a3e8685120cfb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c241ecd2b46058c15b4cd0c1c510258" id="r_a0c241ecd2b46058c15b4cd0c1c510258"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c241ecd2b46058c15b4cd0c1c510258">ansi_strip_ansi</a> (const char *str)</td></tr>
<tr class="memdesc:a0c241ecd2b46058c15b4cd0c1c510258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove ANSI escape codes using the <a class="el" href="ansi_8c.html" title="ANSI terminal control helpers and telnet negotiation support.">ansi.c</a> parser utilities.  <br /></td></tr>
<tr class="separator:a0c241ecd2b46058c15b4cd0c1c510258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a364826f0b067db822b7c97afcfafae5a" id="r_a364826f0b067db822b7c97afcfafae5a"><td class="memItemLeft" align="right" valign="top"><a id="a364826f0b067db822b7c97afcfafae5a" name="a364826f0b067db822b7c97afcfafae5a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ansi_strip_ansi_len</b> (const char *str)</td></tr>
<tr class="memdesc:a364826f0b067db822b7c97afcfafae5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count visible characters ignoring ANSI escape sequences using <a class="el" href="ansi_8c.html" title="ANSI terminal control helpers and telnet negotiation support.">ansi.c</a> parser utilities. <br /></td></tr>
<tr class="separator:a364826f0b067db822b7c97afcfafae5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade85bc7b6fc3b12db0bd3bc54fbfbf96" id="r_ade85bc7b6fc3b12db0bd3bc54fbfbf96"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade85bc7b6fc3b12db0bd3bc54fbfbf96">ansi_map_states_colorstate</a> (const char *s, <a class="el" href="structColorState.html">ColorState</a> **states, char **stripped)</td></tr>
<tr class="memdesc:ade85bc7b6fc3b12db0bd3bc54fbfbf96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map ANSI state for every character using modern <a class="el" href="structColorState.html" title="Complete text formatting state.">ColorState</a> format.  <br /></td></tr>
<tr class="separator:ade85bc7b6fc3b12db0bd3bc54fbfbf96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3e1c988affc68882edff6f39c416eb3" id="r_ac3e1c988affc68882edff6f39c416eb3"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac3e1c988affc68882edff6f39c416eb3">ansi_states_to_sequence</a> (<a class="el" href="structColorState.html">ColorState</a> *states, int count, ColorType type)</td></tr>
<tr class="memdesc:ac3e1c988affc68882edff6f39c416eb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate ANSI escape sequence string from an array of <a class="el" href="structColorState.html" title="Complete text formatting state.">ColorState</a>.  <br /></td></tr>
<tr class="separator:ac3e1c988affc68882edff6f39c416eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a326bd8e19a69c35941bd1c1a0f395718" id="r_a326bd8e19a69c35941bd1c1a0f395718"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structColorState.html">ColorState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a326bd8e19a69c35941bd1c1a0f395718">ansi_parse_sequence</a> (const char **ansi_ptr)</td></tr>
<tr class="memdesc:a326bd8e19a69c35941bd1c1a0f395718"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse ANSI escape sequence and return <a class="el" href="structColorState.html" title="Complete text formatting state.">ColorState</a>.  <br /></td></tr>
<tr class="separator:a326bd8e19a69c35941bd1c1a0f395718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a104f0abc0b0a9e501afa5d4db999800e" id="r_a104f0abc0b0a9e501afa5d4db999800e"><td class="memItemLeft" align="right" valign="top"><a id="a104f0abc0b0a9e501afa5d4db999800e" name="a104f0abc0b0a9e501afa5d4db999800e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>level_ansi_stream</b> (const char *s, bool ansi, bool xterm, bool truecolors, void(*flush_fn)(const char *data, size_t len, void *ctx), void *ctx)</td></tr>
<tr class="separator:a104f0abc0b0a9e501afa5d4db999800e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac311df3ec3fa40aed5400d732b4dd184" id="r_ac311df3ec3fa40aed5400d732b4dd184"><td class="memItemLeft" align="right" valign="top"><a id="ac311df3ec3fa40aed5400d732b4dd184" name="ac311df3ec3fa40aed5400d732b4dd184"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><b>normal_to_white</b> (const char *raw)</td></tr>
<tr class="separator:ac311df3ec3fa40aed5400d732b4dd184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fb5ff887ca132e1e1a2b797ca59894e" id="r_a0fb5ff887ca132e1e1a2b797ca59894e"><td class="memItemLeft" align="right" valign="top"><a id="a0fb5ff887ca132e1e1a2b797ca59894e" name="a0fb5ff887ca132e1e1a2b797ca59894e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>skip_esccode</b> (char **s)</td></tr>
<tr class="separator:a0fb5ff887ca132e1e1a2b797ca59894e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a860915ab1e4fa7b3525b4ef1e18dd4ea" id="r_a860915ab1e4fa7b3525b4ef1e18dd4ea"><td class="memItemLeft" align="right" valign="top"><a id="a860915ab1e4fa7b3525b4ef1e18dd4ea" name="a860915ab1e4fa7b3525b4ef1e18dd4ea"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><b>remap_colors</b> (const char *s, int *cmap)</td></tr>
<tr class="separator:a860915ab1e4fa7b3525b4ef1e18dd4ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d3bba00d3d8d7165edc140e28ae3206" id="r_a2d3bba00d3d8d7165edc140e28ae3206"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d3bba00d3d8d7165edc140e28ae3206">ansi_to_mushcode</a> (const char *input)</td></tr>
<tr class="memdesc:a2d3bba00d3d8d7165edc140e28ae3206"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a string with ANSI escape sequences to a string with MUSHcode.  <br /></td></tr>
<tr class="separator:a2d3bba00d3d8d7165edc140e28ae3206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad57dcd168ca9d98d1e4023886713e560" id="r_ad57dcd168ca9d98d1e4023886713e560"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad57dcd168ca9d98d1e4023886713e560">convert_mush_to_ansi</a> (const char *input, ColorType type)</td></tr>
<tr class="memdesc:ad57dcd168ca9d98d1e4023886713e560"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a string with MUSHcode to a string with ANSI escape sequences.  <br /></td></tr>
<tr class="separator:ad57dcd168ca9d98d1e4023886713e560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee1a252e3041ffa4a64c4d2f808fd41b" id="r_aee1a252e3041ffa4a64c4d2f808fd41b"><td class="memItemLeft" align="right" valign="top"><a id="aee1a252e3041ffa4a64c4d2f808fd41b" name="aee1a252e3041ffa4a64c4d2f808fd41b"></a>
ColorType&#160;</td><td class="memItemRight" valign="bottom"><b>resolve_color_type</b> (dbref player, dbref cause)</td></tr>
<tr class="separator:aee1a252e3041ffa4a64c4d2f808fd41b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a1c43aeb6bda24e442288c8dcdc29d94c" id="r_a1c43aeb6bda24e442288c8dcdc29d94c"><td class="memItemLeft" align="right" valign="top"><a id="a1c43aeb6bda24e442288c8dcdc29d94c" name="a1c43aeb6bda24e442288c8dcdc29d94c"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>C_ANSI_BLACK</b> = 30</td></tr>
<tr class="memdesc:a1c43aeb6bda24e442288c8dcdc29d94c"><td class="mdescLeft">&#160;</td><td class="mdescRight">ANSI color code constants and definitions. <br /></td></tr>
<tr class="separator:a1c43aeb6bda24e442288c8dcdc29d94c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40c84f34b302cb5daf77495c9083d03d" id="r_a40c84f34b302cb5daf77495c9083d03d"><td class="memItemLeft" align="right" valign="top"><a id="a40c84f34b302cb5daf77495c9083d03d" name="a40c84f34b302cb5daf77495c9083d03d"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>C_ANSI_NUM</b> = 48</td></tr>
<tr class="separator:a40c84f34b302cb5daf77495c9083d03d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a151565e1c10b49704b481556b0941bf3" id="r_a151565e1c10b49704b481556b0941bf3"><td class="memItemLeft" align="right" valign="top"><a id="a151565e1c10b49704b481556b0941bf3" name="a151565e1c10b49704b481556b0941bf3"></a>
const char&#160;</td><td class="memItemRight" valign="bottom"><b>C_ANSI_CSI</b> = '['</td></tr>
<tr class="separator:a151565e1c10b49704b481556b0941bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a657dd969a689e13d470d4ccbb34c3adf" id="r_a657dd969a689e13d470d4ccbb34c3adf"><td class="memItemLeft" align="right" valign="top"><a id="a657dd969a689e13d470d4ccbb34c3adf" name="a657dd969a689e13d470d4ccbb34c3adf"></a>
const char&#160;</td><td class="memItemRight" valign="bottom"><b>C_ANSI_RESET</b> [] = &quot;0&quot;</td></tr>
<tr class="separator:a657dd969a689e13d470d4ccbb34c3adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ecd0295f675ff2a460d17b6c3f816af" id="r_a5ecd0295f675ff2a460d17b6c3f816af"><td class="memItemLeft" align="right" valign="top"><a id="a5ecd0295f675ff2a460d17b6c3f816af" name="a5ecd0295f675ff2a460d17b6c3f816af"></a>
const char&#160;</td><td class="memItemRight" valign="bottom"><b>C_ANSI_BOLD</b> [] = &quot;1&quot;</td></tr>
<tr class="separator:a5ecd0295f675ff2a460d17b6c3f816af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d9d73073f8003eea7108b0b8c9578d4" id="r_a9d9d73073f8003eea7108b0b8c9578d4"><td class="memItemLeft" align="right" valign="top"><a id="a9d9d73073f8003eea7108b0b8c9578d4" name="a9d9d73073f8003eea7108b0b8c9578d4"></a>
const char&#160;</td><td class="memItemRight" valign="bottom"><b>C_ANSI_UNDERLINE</b> [] = &quot;4&quot;</td></tr>
<tr class="separator:a9d9d73073f8003eea7108b0b8c9578d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3243ab9179127a03ee2b56b6fa2459be" id="r_a3243ab9179127a03ee2b56b6fa2459be"><td class="memItemLeft" align="right" valign="top"><a id="a3243ab9179127a03ee2b56b6fa2459be" name="a3243ab9179127a03ee2b56b6fa2459be"></a>
const char&#160;</td><td class="memItemRight" valign="bottom"><b>C_ANSI_BLINK</b> [] = &quot;5&quot;</td></tr>
<tr class="separator:a3243ab9179127a03ee2b56b6fa2459be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e4c44be4566c88b571b3e424aea0292" id="r_a4e4c44be4566c88b571b3e424aea0292"><td class="memItemLeft" align="right" valign="top"><a id="a4e4c44be4566c88b571b3e424aea0292" name="a4e4c44be4566c88b571b3e424aea0292"></a>
const char&#160;</td><td class="memItemRight" valign="bottom"><b>C_ANSI_REVERSE</b> [] = &quot;7&quot;</td></tr>
<tr class="separator:a4e4c44be4566c88b571b3e424aea0292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a16503eeeed9261a95d51dd7699bb3a" id="r_a7a16503eeeed9261a95d51dd7699bb3a"><td class="memItemLeft" align="right" valign="top"><a id="a7a16503eeeed9261a95d51dd7699bb3a" name="a7a16503eeeed9261a95d51dd7699bb3a"></a>
const char&#160;</td><td class="memItemRight" valign="bottom"><b>C_ANSI_NORMAL_INTENSITY</b> [] = &quot;22&quot;</td></tr>
<tr class="separator:a7a16503eeeed9261a95d51dd7699bb3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad232cc6eb9a6b241fc63158e7336f401" id="r_ad232cc6eb9a6b241fc63158e7336f401"><td class="memItemLeft" align="right" valign="top"><a id="ad232cc6eb9a6b241fc63158e7336f401" name="ad232cc6eb9a6b241fc63158e7336f401"></a>
const char&#160;</td><td class="memItemRight" valign="bottom"><b>C_ANSI_NO_UNDERLINE</b> [] = &quot;24&quot;</td></tr>
<tr class="separator:ad232cc6eb9a6b241fc63158e7336f401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cacff4dd81785193197c94240a4fbc2" id="r_a6cacff4dd81785193197c94240a4fbc2"><td class="memItemLeft" align="right" valign="top"><a id="a6cacff4dd81785193197c94240a4fbc2" name="a6cacff4dd81785193197c94240a4fbc2"></a>
const char&#160;</td><td class="memItemRight" valign="bottom"><b>C_ANSI_NO_BLINK</b> [] = &quot;25&quot;</td></tr>
<tr class="separator:a6cacff4dd81785193197c94240a4fbc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c924c5b0bab473f38e5f44ec4e3dd1d" id="r_a3c924c5b0bab473f38e5f44ec4e3dd1d"><td class="memItemLeft" align="right" valign="top"><a id="a3c924c5b0bab473f38e5f44ec4e3dd1d" name="a3c924c5b0bab473f38e5f44ec4e3dd1d"></a>
const char&#160;</td><td class="memItemRight" valign="bottom"><b>C_ANSI_NO_REVERSE</b> [] = &quot;27&quot;</td></tr>
<tr class="separator:a3c924c5b0bab473f38e5f44ec4e3dd1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f22d3f3792bd62172292fe9fc248a87" id="r_a9f22d3f3792bd62172292fe9fc248a87"><td class="memItemLeft" align="right" valign="top"><a id="a9f22d3f3792bd62172292fe9fc248a87" name="a9f22d3f3792bd62172292fe9fc248a87"></a>
const char&#160;</td><td class="memItemRight" valign="bottom"><b>C_ANSI_FOREGROUND_RESET</b> [] = &quot;39&quot;</td></tr>
<tr class="separator:a9f22d3f3792bd62172292fe9fc248a87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6de90b307258db7f444ebd8f1aa82b0" id="r_af6de90b307258db7f444ebd8f1aa82b0"><td class="memItemLeft" align="right" valign="top"><a id="af6de90b307258db7f444ebd8f1aa82b0" name="af6de90b307258db7f444ebd8f1aa82b0"></a>
const char&#160;</td><td class="memItemRight" valign="bottom"><b>C_ANSI_BACKGROUND_RESET</b> [] = &quot;49&quot;</td></tr>
<tr class="separator:af6de90b307258db7f444ebd8f1aa82b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05367a555b10afda1419c66ff2b5c2c0" id="r_a05367a555b10afda1419c66ff2b5c2c0"><td class="memItemLeft" align="right" valign="top"><a id="a05367a555b10afda1419c66ff2b5c2c0" name="a05367a555b10afda1419c66ff2b5c2c0"></a>
const char&#160;</td><td class="memItemRight" valign="bottom"><b>C_ANSI_END</b> [] = &quot;m&quot;</td></tr>
<tr class="separator:a05367a555b10afda1419c66ff2b5c2c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a330226a8a739e5cd22a7870960b4b812" id="r_a330226a8a739e5cd22a7870960b4b812"><td class="memItemLeft" align="right" valign="top"><a id="a330226a8a739e5cd22a7870960b4b812" name="a330226a8a739e5cd22a7870960b4b812"></a>
const char&#160;</td><td class="memItemRight" valign="bottom"><b>C_ANSI_RESET_SEQUENCE</b> [] = &quot;\033[0m&quot;</td></tr>
<tr class="separator:a330226a8a739e5cd22a7870960b4b812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a973535f52d100fd6e4f350abddf3a4c0" id="r_a973535f52d100fd6e4f350abddf3a4c0"><td class="memItemLeft" align="right" valign="top"><a id="a973535f52d100fd6e4f350abddf3a4c0" name="a973535f52d100fd6e4f350abddf3a4c0"></a>
const char&#160;</td><td class="memItemRight" valign="bottom"><b>C_ANSI_XTERM_PREFIX_FG</b> [] = &quot;38;5;&quot;</td></tr>
<tr class="separator:a973535f52d100fd6e4f350abddf3a4c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c3f622fe08f2946f2d3c6272a48f143" id="r_a8c3f622fe08f2946f2d3c6272a48f143"><td class="memItemLeft" align="right" valign="top"><a id="a8c3f622fe08f2946f2d3c6272a48f143" name="a8c3f622fe08f2946f2d3c6272a48f143"></a>
const char&#160;</td><td class="memItemRight" valign="bottom"><b>C_ANSI_XTERM_PREFIX_BG</b> [] = &quot;48;5;&quot;</td></tr>
<tr class="separator:a8c3f622fe08f2946f2d3c6272a48f143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36248ac8b5940d9d6e762760ee331cd9" id="r_a36248ac8b5940d9d6e762760ee331cd9"><td class="memItemLeft" align="right" valign="top"><a id="a36248ac8b5940d9d6e762760ee331cd9" name="a36248ac8b5940d9d6e762760ee331cd9"></a>
const char&#160;</td><td class="memItemRight" valign="bottom"><b>C_ANSI_TRUECOLOR_PREFIX_FG</b> [] = &quot;38;2;&quot;</td></tr>
<tr class="separator:a36248ac8b5940d9d6e762760ee331cd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dca0377fe53e26d3d5bc59dea332083" id="r_a2dca0377fe53e26d3d5bc59dea332083"><td class="memItemLeft" align="right" valign="top"><a id="a2dca0377fe53e26d3d5bc59dea332083" name="a2dca0377fe53e26d3d5bc59dea332083"></a>
const char&#160;</td><td class="memItemRight" valign="bottom"><b>C_ANSI_TRUECOLOR_PREFIX_BG</b> [] = &quot;48;2;&quot;</td></tr>
<tr class="separator:a2dca0377fe53e26d3d5bc59dea332083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab08b9f22d0d844b296bfdfab1ce0955e" id="r_ab08b9f22d0d844b296bfdfab1ce0955e"><td class="memItemLeft" align="right" valign="top"><a id="ab08b9f22d0d844b296bfdfab1ce0955e" name="ab08b9f22d0d844b296bfdfab1ce0955e"></a>
const char&#160;</td><td class="memItemRight" valign="bottom"><b>C_ANSI_NORMAL_SEQ</b> [] = &quot;\033[0m&quot;</td></tr>
<tr class="separator:ab08b9f22d0d844b296bfdfab1ce0955e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89fbb02f76c9940793a1517f687fe092" id="r_a89fbb02f76c9940793a1517f687fe092"><td class="memItemLeft" align="right" valign="top"><a id="a89fbb02f76c9940793a1517f687fe092" name="a89fbb02f76c9940793a1517f687fe092"></a>
const char&#160;</td><td class="memItemRight" valign="bottom"><b>C_ANSI_BOLD_SEQ</b> [] = &quot;\033[1m&quot;</td></tr>
<tr class="separator:a89fbb02f76c9940793a1517f687fe092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c4d9cb2f14de250c9cf1be3248b50a0" id="r_a2c4d9cb2f14de250c9cf1be3248b50a0"><td class="memItemLeft" align="right" valign="top"><a id="a2c4d9cb2f14de250c9cf1be3248b50a0" name="a2c4d9cb2f14de250c9cf1be3248b50a0"></a>
<a class="el" href="structColorEntry.html">ColorEntry</a>&#160;</td><td class="memItemRight" valign="bottom"><b>colorDefinitions</b> []</td></tr>
<tr class="separator:a2c4d9cb2f14de250c9cf1be3248b50a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>ANSI terminal control helpers and telnet negotiation support. </p>
<dl class="section author"><dt>Author</dt><dd>TinyMUSH development team (<a href="https://github.com/TinyMUSH">https://github.com/TinyMUSH</a>) </dd></dl>
<dl class="section version"><dt>Version</dt><dd>4.0</dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>Copyright (C) 1989-2025 TinyMUSH development team. You may distribute under the terms the Artistic License, as specified in the COPYING file. </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a485875ebf5bbab9e634e0f1420b6251b" name="a485875ebf5bbab9e634e0f1420b6251b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a485875ebf5bbab9e634e0f1420b6251b">&#9670;&#160;</a></span>ansi_char_bright_to_sequence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * ansi_char_bright_to_sequence </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert ansi character code (x? uppercase) to bright ansi sequence. Replacement for the ansiChar_Bright lookup table using colorDefinitions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Character to convert (should match lowercase versions) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const char* Bright ANSI sequence or empty string if not found </dd></dl>

</div>
</div>
<a id="a0d695364d336b94905b4f2089ef1efc5" name="a0d695364d336b94905b4f2089ef1efc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d695364d336b94905b4f2089ef1efc5">&#9670;&#160;</a></span>ansi_char_to_num()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ansi_char_to_num </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert ansi character code to numeric values. Replacement for the ansiNum lookup table using colorDefinitions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>ANSI character </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int ANSI numeric value or 0 if not found </dd></dl>

</div>
</div>
<a id="a10dfbb563532866525801626d470654a" name="a10dfbb563532866525801626d470654a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10dfbb563532866525801626d470654a">&#9670;&#160;</a></span>ansi_char_to_sequence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * ansi_char_to_sequence </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert ansi character code (x?) to ansi sequence. Replacement for the ansiChar lookup table using colorDefinitions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Character to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const char* ANSI sequence or empty string if not found </dd></dl>

</div>
</div>
<a id="a18b1d3b66e84fb99814b4bf240f7ba42" name="a18b1d3b66e84fb99814b4bf240f7ba42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18b1d3b66e84fb99814b4bf240f7ba42">&#9670;&#160;</a></span>ansi_ciede2000()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ansi_ciede2000 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structColorCIELab.html">ColorCIELab</a></td>          <td class="paramname"><span class="paramname"><em>lab1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structColorCIELab.html">ColorCIELab</a></td>          <td class="paramname"><span class="paramname"><em>lab2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the CIEDE2000 distance between two CIELAB colors. </p>
<p>This function implements the CIEDE2000 formula to measure the perceptual difference between two colors, taking into account luminance, chroma, and hue with advanced corrections.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lab1</td><td>The first CIELAB color. </td></tr>
    <tr><td class="paramname">lab2</td><td>The second CIELAB color. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The CIEDE2000 distance (smaller = more similar). </dd></dl>

</div>
</div>
<a id="a925d6c1ab43d953c312a7203a9658cef" name="a925d6c1ab43d953c312a7203a9658cef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a925d6c1ab43d953c312a7203a9658cef">&#9670;&#160;</a></span>ansi_find_closest_color_with_lab()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structColorEntry.html">ColorEntry</a> ansi_find_closest_color_with_lab </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structColorCIELab.html">ColorCIELab</a></td>          <td class="paramname"><span class="paramname"><em>lab</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ColorType</td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the closest ANSI or XTerm color to a given CIELAB color. </p>
<p>Uses CIEDE2000 distance to compare colors and select the best perceptual approximation in the specified palette.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lab</td><td>The target CIELAB color. </td></tr>
    <tr><td class="paramname">type</td><td>The palette type (ColorTypeAnsi or ColorTypeXTerm). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The closest color definition. </dd></dl>

</div>
</div>
<a id="a0e70a884881eb06af93d5ba2a0418c78" name="a0e70a884881eb06af93d5ba2a0418c78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e70a884881eb06af93d5ba2a0418c78">&#9670;&#160;</a></span>ansi_get_color_from_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ansi_get_color_from_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structColorState.html">ColorState</a> *</td>          <td class="paramname"><span class="paramname"><em>color</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>is_background</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the foreground or background color from an XTerm index. </p>
<p>Looks up the corresponding color in the table and updates the state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td>Pointer to the color state to modify. </td></tr>
    <tr><td class="paramname">index</td><td>The XTerm index (0-255). </td></tr>
    <tr><td class="paramname">is_background</td><td>true to set background, false for foreground. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3bdc82d815125f5a5a354bee287ddd65" name="a3bdc82d815125f5a5a354bee287ddd65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bdc82d815125f5a5a354bee287ddd65">&#9670;&#160;</a></span>ansi_get_color_from_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ansi_get_color_from_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structColorState.html">ColorState</a> *</td>          <td class="paramname"><span class="paramname"><em>color</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>is_background</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the foreground or background color from a color name. </p>
<p>Searches the color table for the name and uses LAB to find the closest ANSI.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td>Pointer to the color state to modify. </td></tr>
    <tr><td class="paramname">name</td><td>The color name (e.g. "red", "blue"). </td></tr>
    <tr><td class="paramname">is_background</td><td>true to set background, false for foreground. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a72b1530ed14defc2cef739cfddecf5d4" name="a72b1530ed14defc2cef739cfddecf5d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72b1530ed14defc2cef739cfddecf5d4">&#9670;&#160;</a></span>ansi_get_color_from_rgb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ansi_get_color_from_rgb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structColorState.html">ColorState</a> *</td>          <td class="paramname"><span class="paramname"><em>color</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structColorRGB.html">ColorRGB</a></td>          <td class="paramname"><span class="paramname"><em>rgb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>is_background</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the foreground or background color from an RGB color. </p>
<p>Converts the RGB color to perceptually close ANSI and XTerm approximations and updates the color state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td>Pointer to the color state to modify. </td></tr>
    <tr><td class="paramname">rgb</td><td>The source RGB color. </td></tr>
    <tr><td class="paramname">is_background</td><td>true to set background, false for foreground. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6d5c4c199abf39e759cbf884c7980e2b" name="a6d5c4c199abf39e759cbf884c7980e2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d5c4c199abf39e759cbf884c7980e2b">&#9670;&#160;</a></span>ansi_get_color_from_text()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ansi_get_color_from_text </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structColorState.html">ColorState</a> *</td>          <td class="paramname"><span class="paramname"><em>color</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>text</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>is_background</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses a hexadecimal or decimal string to set an RGB color. </p>
<p>Supports formats like #RRGGBB, RRGGBB, RRRGGGBBB, etc., and sets the foreground or background color accordingly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td>Pointer to the color state to modify. </td></tr>
    <tr><td class="paramname">text</td><td>The string to parse (modified in place). </td></tr>
    <tr><td class="paramname">is_background</td><td>true to set background, false for foreground. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if parsing succeeded, false otherwise. </dd></dl>

</div>
</div>
<a id="ade85bc7b6fc3b12db0bd3bc54fbfbf96" name="ade85bc7b6fc3b12db0bd3bc54fbfbf96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade85bc7b6fc3b12db0bd3bc54fbfbf96">&#9670;&#160;</a></span>ansi_map_states_colorstate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ansi_map_states_colorstate </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structColorState.html">ColorState</a> **</td>          <td class="paramname"><span class="paramname"><em>states</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>stripped</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map ANSI state for every character using modern <a class="el" href="structColorState.html" title="Complete text formatting state.">ColorState</a> format. </p>
<p>Supports ANSI basic, xterm 256-color, and truecolor.</p>
<p>Caller must free <code>*states</code> with XFREE(states, "ansi_map_states_colorstate_states") and <code>*stripped</code> with XFREE(stripped, "ansi_map_states_colorstate_stripped").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Input string (may contain ANSI/xterm/truecolor escape sequences) </td></tr>
    <tr><td class="paramname">states</td><td>Out: allocated array of <a class="el" href="structColorState.html" title="Complete text formatting state.">ColorState</a> for each character </td></tr>
    <tr><td class="paramname">stripped</td><td>Out: stripped string without ANSI codes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int Number of characters mapped </dd></dl>

</div>
</div>
<a id="a4447edd53423a6ecc0a63320eafd3279" name="a4447edd53423a6ecc0a63320eafd3279"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4447edd53423a6ecc0a63320eafd3279">&#9670;&#160;</a></span>ansi_parse_ansi_to_sequences()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ansi_parse_ansi_to_sequences </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>input</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structColorSequence.html">ColorSequence</a> *</td>          <td class="paramname"><span class="paramname"><em>sequences</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses a string with ANSI escape sequences and converts it to a <a class="el" href="structColorSequence.html" title="Parsed color sequence information.">ColorSequence</a>. </p>
<p>This function scans the input string for ANSI escape sequences, interprets them to update the color state, and records the color changes in the provided <a class="el" href="structColorSequence.html" title="Parsed color sequence information.">ColorSequence</a>. It also returns the plain text with ANSI codes removed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The input string containing ANSI sequences. </td></tr>
    <tr><td class="paramname">sequences</td><td>The <a class="el" href="structColorSequence.html" title="Parsed color sequence information.">ColorSequence</a> to populate with color changes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A newly allocated string with ANSI sequences removed, or NULL on error.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The caller is responsible for freeing the returned string and the sequences-&gt;data. </dd></dl>

</div>
</div>
<a id="a577ecea9667560f8636243f0521fbc70" name="a577ecea9667560f8636243f0521fbc70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a577ecea9667560f8636243f0521fbc70">&#9670;&#160;</a></span>ansi_parse_color_from_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ansi_parse_color_from_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structColorState.html">ColorState</a> *</td>          <td class="paramname"><span class="paramname"><em>color</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>color_str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>is_background</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses a complex color string and sets the corresponding color. </p>
<p>Supports color names, hex values, and MUSH code. Handles wrappers like &lt;color&gt; or +color. If '/' is present, the part before is foreground, after is background.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td>Pointer to the color state to modify. </td></tr>
    <tr><td class="paramname">color_str</td><td>The string to parse. </td></tr>
    <tr><td class="paramname">is_background</td><td>true to set background, false for foreground (ignored if '/' present). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if parsing succeeded, false otherwise. </dd></dl>

</div>
</div>
<a id="a18b234e1abc49099a86ddf807cd5b71b" name="a18b234e1abc49099a86ddf807cd5b71b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18b234e1abc49099a86ddf807cd5b71b">&#9670;&#160;</a></span>ansi_parse_embedded_sequences()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ansi_parse_embedded_sequences </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>input</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structColorSequence.html">ColorSequence</a> *</td>          <td class="paramname"><span class="paramname"><em>sequences</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses embedded ANSI sequences in a string marked with 'x<code>'. </code></p>
<p>Scans the input string for patterns like 'xred' or 'xred/blue', parses the code using ansi_parse_color_from_string, and builds an array of <a class="el" href="structColorSequence.html" title="Parsed color sequence information.">ColorSequence</a> with positions and decoded <a class="el" href="structColorState.html" title="Complete text formatting state.">ColorState</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The input string to parse. </td></tr>
    <tr><td class="paramname">sequences</td><td>Pointer to the array of <a class="el" href="structColorSequence.html" title="Parsed color sequence information.">ColorSequence</a> (allocated by the function). </td></tr>
    <tr><td class="paramname">count</td><td>Pointer to the number of sequences found. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on error (memory allocation failure).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The caller is responsible for freeing the allocated sequences array. </dd></dl>

</div>
</div>
<a id="a326bd8e19a69c35941bd1c1a0f395718" name="a326bd8e19a69c35941bd1c1a0f395718"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a326bd8e19a69c35941bd1c1a0f395718">&#9670;&#160;</a></span>ansi_parse_sequence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structColorState.html">ColorState</a> ansi_parse_sequence </td>
          <td>(</td>
          <td class="paramtype">const char **</td>          <td class="paramname"><span class="paramname"><em>ansi_ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse ANSI escape sequence and return <a class="el" href="structColorState.html" title="Complete text formatting state.">ColorState</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ansi_ptr</td><td>Pointer to string pointer, will be advanced past the parsed sequence </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structColorState.html" title="Complete text formatting state.">ColorState</a> Parsed color state </dd></dl>

</div>
</div>
<a id="a10019119f7dc128e9848f4e04b6ce4f1" name="a10019119f7dc128e9848f4e04b6ce4f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10019119f7dc128e9848f4e04b6ce4f1">&#9670;&#160;</a></span>ansi_parse_single_x_code()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ansi_parse_single_x_code </td>
          <td>(</td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>input_ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structColorState.html">ColorState</a> *</td>          <td class="paramname"><span class="paramname"><em>color_out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *</td>          <td class="paramname"><span class="paramname"><em>current_highlight</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses a single x color code from the current position. </p>
<p>This function is designed for incremental parsing in <a class="el" href="eval_8c.html#aa8b1b12892bbf3fb39d1e11e646fdfb7" title="Evaluate an expression string in place, expanding substitutions and functions.">eval_expression_string()</a>. It parses one color code starting at *input_ptr and advances the pointer past the consumed characters.</p>
<p>Supported formats:</p><ul>
<li>Bracketed: x&lt;color&gt;, x&lt;color/bgcolor&gt;, x+&lt;color&gt;</li>
<li>Non-bracketed: xr, xh, xn, etc.</li>
<li>Combined: x&lt;red&gt;/&lt;blue&gt;</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_ptr</td><td>Pointer to pointer to current position (after "%x"). Updated on success. </td></tr>
    <tr><td class="paramname">color_out</td><td>Output <a class="el" href="structColorState.html" title="Complete text formatting state.">ColorState</a> structure. Must be initialized by caller. </td></tr>
    <tr><td class="paramname">current_highlight</td><td>Pointer to persistent highlight state tracker. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of characters consumed (&gt;0) on success, 0 if invalid or no code found.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The caller must initialize color_out before calling (typically zero it). </dd>
<dd>
The input_ptr is only advanced on successful parsing. </dd></dl>

</div>
</div>
<a id="a287dfc7f24bd306f6a627a9cec89d06e" name="a287dfc7f24bd306f6a627a9cec89d06e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a287dfc7f24bd306f6a627a9cec89d06e">&#9670;&#160;</a></span>ansi_parse_x_to_sequence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * ansi_parse_x_to_sequence </td>
          <td>(</td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ColorType</td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses a x color code and generates the corresponding ANSI escape sequence. </p>
<p>Parses a color code starting from x, advances the pointer, and generates the ANSI sequence based on the specified color type (ANSI, XTerm, TrueColor).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the string pointer (advanced after parsing). </td></tr>
    <tr><td class="paramname">type</td><td>The color type to generate the sequence for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A newly allocated string with the ANSI escape sequence, or NULL on error. </dd></dl>

</div>
</div>
<a id="aedbc240c83b027a81456f399edee9606" name="aedbc240c83b027a81456f399edee9606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedbc240c83b027a81456f399edee9606">&#9670;&#160;</a></span>ansi_rgb_to_cielab()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structColorCIELab.html">ColorCIELab</a> ansi_rgb_to_cielab </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structColorRGB.html">ColorRGB</a></td>          <td class="paramname"><span class="paramname"><em>color</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an RGB color to CIELAB color space. </p>
<p>This function applies the sRGB to XYZ transformation then XYZ to CIELAB using the D65 reference white and CIE 1976 formulas.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td>The RGB color to convert (values 0-255). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The equivalent color in CIELAB. </dd></dl>

</div>
</div>
<a id="ac3e1c988affc68882edff6f39c416eb3" name="ac3e1c988affc68882edff6f39c416eb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3e1c988affc68882edff6f39c416eb3">&#9670;&#160;</a></span>ansi_states_to_sequence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * ansi_states_to_sequence </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structColorState.html">ColorState</a> *</td>          <td class="paramname"><span class="paramname"><em>states</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ColorType</td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate ANSI escape sequence string from an array of <a class="el" href="structColorState.html" title="Complete text formatting state.">ColorState</a>. </p>
<p>Iterates through the array of <a class="el" href="structColorState.html" title="Complete text formatting state.">ColorState</a>, generating transition sequences for state changes, and appends a final reset to normal.</p>
<p>Caller must free the returned string with XFREE().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">states</td><td>Array of <a class="el" href="structColorState.html" title="Complete text formatting state.">ColorState</a> structures </td></tr>
    <tr><td class="paramname">count</td><td>Number of states in the array </td></tr>
    <tr><td class="paramname">type</td><td>ColorType to use for sequence generation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Newly allocated string with ANSI sequences, or NULL on error </dd></dl>

</div>
</div>
<a id="a0c241ecd2b46058c15b4cd0c1c510258" name="a0c241ecd2b46058c15b4cd0c1c510258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c241ecd2b46058c15b4cd0c1c510258">&#9670;&#160;</a></span>ansi_strip_ansi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * ansi_strip_ansi </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove ANSI escape codes using the <a class="el" href="ansi_8c.html" title="ANSI terminal control helpers and telnet negotiation support.">ansi.c</a> parser utilities. </p>
<p>Caller frees the returned buffer with XFREE(). </p>

</div>
</div>
<a id="a2d3bba00d3d8d7165edc140e28ae3206" name="a2d3bba00d3d8d7165edc140e28ae3206"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d3bba00d3d8d7165edc140e28ae3206">&#9670;&#160;</a></span>ansi_to_mushcode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * ansi_to_mushcode </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>input</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a string with ANSI escape sequences to a string with MUSHcode. </p>
<p>Parses the input string for ANSI sequences, extracts the plain text and color changes, then reconstructs the string with MUSHcode (x<code>) inserted at the appropriate positions.</code></p>
<p><code></p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The input string containing ANSI escape sequences. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A newly allocated string with MUSHcode, or NULL on error. </dd></dl>
<p></code></p>

</div>
</div>
<a id="a9cebcc38b9c124e68d8a327fa8490a73" name="a9cebcc38b9c124e68d8a327fa8490a73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cebcc38b9c124e68d8a327fa8490a73">&#9670;&#160;</a></span>ansi_transition_colorstate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * ansi_transition_colorstate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structColorState.html">ColorState</a></td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structColorState.html">ColorState</a></td>          <td class="paramname"><span class="paramname"><em>to</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ColorType</td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>no_default_bg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build an ANSI escape sequence to transition between two <a class="el" href="structColorState.html" title="Complete text formatting state.">ColorState</a> values. </p>
<p>Uses the modern <a class="el" href="structColorState.html" title="Complete text formatting state.">ColorState</a> API and honors the requested ColorType (ANSI, XTerm, TrueColor). When attributes or colors are being cleared, the function emits a reset (ESC[0m) before applying the target state to keep the transition safe.</p>
<p>Caller must free the returned buffer with XFREE(). </p>

</div>
</div>
<a id="a6f2dfc1be1e8498eede545d0f5f3da3d" name="a6f2dfc1be1e8498eede545d0f5f3da3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f2dfc1be1e8498eede545d0f5f3da3d">&#9670;&#160;</a></span>color_state_to_escape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * color_state_to_escape </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structColorState.html">ColorState</a> *</td>          <td class="paramname"><span class="paramname"><em>color</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ColorType</td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a <a class="el" href="structColorState.html" title="Complete text formatting state.">ColorState</a> to an ANSI escape sequence string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td>The <a class="el" href="structColorState.html" title="Complete text formatting state.">ColorState</a> to convert </td></tr>
    <tr><td class="paramname">type</td><td>The ColorType to use for the sequence </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>char* Allocated string containing the ANSI escape sequence, or NULL on failure </dd></dl>

</div>
</div>
<a id="af1de5e3964b9254739c4d69c548ff327" name="af1de5e3964b9254739c4d69c548ff327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1de5e3964b9254739c4d69c548ff327">&#9670;&#160;</a></span>color_state_to_letters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * color_state_to_letters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structColorState.html">ColorState</a> *</td>          <td class="paramname"><span class="paramname"><em>color</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a letter code string from a <a class="el" href="structColorState.html" title="Complete text formatting state.">ColorState</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td>The color state. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A newly allocated string with the letter codes, or NULL on error. </dd></dl>

</div>
</div>
<a id="a94d0aa911d32eef8396b50b0680588e8" name="a94d0aa911d32eef8396b50b0680588e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94d0aa911d32eef8396b50b0680588e8">&#9670;&#160;</a></span>color_state_to_mush_code()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * color_state_to_mush_code </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structColorState.html">ColorState</a> *</td>          <td class="paramname"><span class="paramname"><em>color</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a mushcode string from a <a class="el" href="structColorState.html" title="Complete text formatting state.">ColorState</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td>The color state. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A newly allocated string with the mushcode, or NULL on error. </dd></dl>

</div>
</div>
<a id="ad57dcd168ca9d98d1e4023886713e560" name="ad57dcd168ca9d98d1e4023886713e560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad57dcd168ca9d98d1e4023886713e560">&#9670;&#160;</a></span>convert_mush_to_ansi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * convert_mush_to_ansi </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>input</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ColorType</td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a string with MUSHcode to a string with ANSI escape sequences. </p>
<p>Parses the input string for embedded MUSHcode sequences (x<code>), extracts the plain text and color changes, then reconstructs the string with ANSI escape sequences inserted at the appropriate positions. Ends with a reset to normal ANSI.</code></p>
<p><code></p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The input string containing MUSHcode. </td></tr>
    <tr><td class="paramname">type</td><td>The ColorType to use for ANSI sequence generation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A newly allocated string with ANSI sequences, or NULL on error. </dd></dl>
<p></code></p>

</div>
</div>
<a id="aa3abb17b5cce10d3ef76e970c6f91e9c" name="aa3abb17b5cce10d3ef76e970c6f91e9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3abb17b5cce10d3ef76e970c6f91e9c">&#9670;&#160;</a></span>mushcode_to_sgr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mushcode_to_sgr </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a mushcode color letter to an ANSI SGR number (30-37 / 40-47). </p>
<p>Supports attribute letters used by ansiNum for compatibility (h,u,f,i,n).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Mushcode character (foreground lowercase, background uppercase) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int Corresponding SGR code, or 0 if not found/unsupported </dd></dl>

</div>
</div>
<a id="a43b21f23eddfbccf6797676310288e2c" name="a43b21f23eddfbccf6797676310288e2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43b21f23eddfbccf6797676310288e2c">&#9670;&#160;</a></span>to_ansi_escape_sequence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ColorStatus to_ansi_escape_sequence </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>buffer_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structColorState.html">ColorState</a> *</td>          <td class="paramname"><span class="paramname"><em>to</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ColorType</td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates an ANSI escape sequence from the color state. </p>
<p>Builds an escape string for attributes and colors according to the specified type. Resets the state after generation if a reset is requested.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer to write the sequence to. </td></tr>
    <tr><td class="paramname">buffer_size</td><td>The buffer size. </td></tr>
    <tr><td class="paramname">offset</td><td>Pointer to the current offset in the buffer (updated). </td></tr>
    <tr><td class="paramname">to</td><td>The color state to convert. </td></tr>
    <tr><td class="paramname">type</td><td>The sequence type (ANSI, XTerm, TrueColor). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting attribute (Set, Reset, or None). </dd></dl>

</div>
</div>
<a id="a7e5d2f2d347f09a618a3e8685120cfb3" name="a7e5d2f2d347f09a618a3e8685120cfb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e5d2f2d347f09a618a3e8685120cfb3">&#9670;&#160;</a></span>translate_string_ansi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * translate_string_ansi </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert ANSI escape sequences to mushcode or strip ANSI codes using the new ANSI API. </p>
<p>This mirrors translate_string() but relies solely on <a class="el" href="ansi_8c.html" title="ANSI terminal control helpers and telnet negotiation support.">ansi.c</a> helpers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Input string (not modified) </td></tr>
    <tr><td class="paramname">type</td><td>When 1 converts to mushcode, when 0 strips ANSI </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Newly allocated string; caller frees with XFREE() </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
