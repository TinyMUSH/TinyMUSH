<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TinyMUSH: src/netmush/alloc.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">TinyMUSH<span id="projectnumber">&#160;3.3</span>
   </div>
   <div id="projectbrief">TinyMUSH Server</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_d49c5bdcdc946239a893bf2d58085e26.html">netmush</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">alloc.c File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Tracked memory allocation, leak detection, and buffer safety helpers.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;config.h&quot;</code><br />
<code>#include &quot;<a class="el" href="constants_8h_source.html">constants.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="typedefs_8h_source.html">typedefs.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="macros_8h_source.html">macros.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="externs_8h_source.html">externs.h</a>&quot;</code><br />
<code>#include &quot;prototypes.h&quot;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for alloc.c:</div>
<div class="dyncontent">
<div class="center"><img src="alloc_8c__incl.png" border="0" usemap="#asrc_2netmush_2alloc_8c" alt=""/></div>
<map name="asrc_2netmush_2alloc_8c" id="asrc_2netmush_2alloc_8c">
<area shape="rect" title="Tracked memory allocation, leak detection, and buffer safety helpers." alt="" coords="391,5,525,31"/>
<area shape="rect" title=" " alt="" coords="5,79,71,105"/>
<area shape="poly" title=" " alt="" coords="391,31,254,51,87,81,86,76,254,46,390,26"/>
<area shape="rect" href="constants_8h.html" title="Global numeric and string constants for flags, limits, and parser tokens." alt="" coords="95,79,184,105"/>
<area shape="poly" title=" " alt="" coords="404,34,199,80,198,75,403,29"/>
<area shape="rect" href="typedefs_8h.html" title="Core typedefs for dbrefs, flags, buffers, and engine data structures." alt="" coords="338,153,418,178"/>
<area shape="poly" title=" " alt="" coords="444,34,423,54,403,80,391,109,384,138,379,137,386,108,398,78,419,51,441,30"/>
<area shape="rect" title=" " alt="" coords="162,226,226,252"/>
<area shape="poly" title=" " alt="" coords="432,34,345,81,294,115,248,155,225,184,208,214,203,211,220,181,244,151,291,110,342,76,430,29"/>
<area shape="rect" href="macros_8h.html" title="Engine&#45;wide macros for memory tracking, flag checks, logging, and utilities." alt="" coords="578,79,652,105"/>
<area shape="poly" title=" " alt="" coords="486,29,576,70,574,75,484,34"/>
<area shape="rect" href="externs_8h.html" title="Shared extern declarations and globals used across the game engine." alt="" coords="676,79,749,105"/>
<area shape="poly" title=" " alt="" coords="502,29,662,74,660,79,500,34"/>
<area shape="rect" href="prototypes_8h_source.html" title=" " alt="" coords="412,79,504,105"/>
<area shape="poly" title=" " alt="" coords="461,31,461,63,455,63,455,31"/>
<area shape="rect" title=" " alt="" coords="684,153,746,178"/>
<area shape="poly" title=" " alt="" coords="472,29,513,64,567,102,620,128,670,147,668,152,618,133,565,107,510,69,469,33"/>
<area shape="rect" title=" " alt="" coords="773,79,836,105"/>
<area shape="poly" title=" " alt="" coords="526,29,759,76,758,81,525,34"/>
<area shape="rect" title=" " alt="" coords="112,153,167,178"/>
<area shape="poly" title=" " alt="" coords="142,105,142,137,137,137,137,105"/>
<area shape="poly" title=" " alt="" coords="348,181,240,223,238,218,346,176"/>
<area shape="rect" title=" " alt="" coords="640,226,700,252"/>
<area shape="poly" title=" " alt="" coords="419,173,626,223,625,228,418,179"/>
<area shape="rect" title=" " alt="" coords="249,226,323,252"/>
<area shape="poly" title=" " alt="" coords="364,181,315,219,312,215,361,177"/>
<area shape="rect" title=" " alt="" coords="347,226,404,252"/>
<area shape="poly" title=" " alt="" coords="380,179,379,211,374,211,375,178"/>
<area shape="rect" title=" " alt="" coords="427,226,508,252"/>
<area shape="poly" title=" " alt="" coords="395,177,442,214,439,219,391,181"/>
<area shape="rect" title=" " alt="" coords="532,226,616,252"/>
<area shape="poly" title=" " alt="" coords="412,176,528,218,526,223,410,181"/>
<area shape="poly" title=" " alt="" coords="446,107,404,144,401,140,443,103"/>
<area shape="poly" title=" " alt="" coords="505,98,565,117,596,131,624,151,648,180,664,211,659,213,643,183,620,155,593,136,563,121,503,103"/>
<area shape="poly" title=" " alt="" coords="461,105,468,211,463,211,456,105"/>
<area shape="poly" title=" " alt="" coords="470,103,557,212,553,216,465,107"/>
<area shape="poly" title=" " alt="" coords="502,103,670,149,669,154,501,108"/>
<area shape="rect" title=" " alt="" coords="543,153,610,178"/>
<area shape="poly" title=" " alt="" coords="479,103,545,142,542,147,477,107"/>
<area shape="rect" href="ansi_8h_source.html" title=" " alt="" coords="258,153,314,178"/>
<area shape="poly" title=" " alt="" coords="430,108,329,149,327,144,428,103"/>
<area shape="poly" title=" " alt="" coords="272,181,223,219,220,215,269,177"/>
<area shape="poly" title=" " alt="" coords="289,179,289,211,283,211,283,179"/>
<area shape="rect" title=" " alt="" coords="71,226,138,252"/>
<area shape="poly" title=" " alt="" coords="259,180,150,223,148,218,257,175"/>
</map>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a97cb58be60bd7f401e470d1f7ecb25ab" id="r_a97cb58be60bd7f401e470d1f7ecb25ab"><td class="memItemLeft" align="right" valign="top"><a id="a97cb58be60bd7f401e470d1f7ecb25ab" name="a97cb58be60bd7f401e470d1f7ecb25ab"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MEMTRACK_ALIGNMENT</b>&#160;&#160;&#160;16</td></tr>
<tr class="memdesc:a97cb58be60bd7f401e470d1f7ecb25ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alignment value for MEMTRACK structures (16 bytes for cache line optimization) <br /></td></tr>
<tr class="separator:a97cb58be60bd7f401e470d1f7ecb25ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d8cc38c36dd811f50d5162c9df08b81" id="r_a8d8cc38c36dd811f50d5162c9df08b81"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d8cc38c36dd811f50d5162c9df08b81">XLOGALLOC</a>(x,  y,  z,  s, ...)</td></tr>
<tr class="separator:a8d8cc38c36dd811f50d5162c9df08b81"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a3133f65ceaa1203d553920c83380a8c8" id="r_a3133f65ceaa1203d553920c83380a8c8"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3133f65ceaa1203d553920c83380a8c8">__xmalloc</a> (size_t size, const char *file, int line, const char *function, const char *var)</td></tr>
<tr class="memdesc:a3133f65ceaa1203d553920c83380a8c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tracked version of malloc().  <br /></td></tr>
<tr class="separator:a3133f65ceaa1203d553920c83380a8c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea2258dce7044417ed32c6f8379046a4" id="r_aea2258dce7044417ed32c6f8379046a4"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aea2258dce7044417ed32c6f8379046a4">__xcalloc</a> (size_t nmemb, size_t size, const char *file, int line, const char *function, const char *var)</td></tr>
<tr class="memdesc:aea2258dce7044417ed32c6f8379046a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tracked version of calloc().  <br /></td></tr>
<tr class="separator:aea2258dce7044417ed32c6f8379046a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26e147a9c099290d3e617e03dda3619d" id="r_a26e147a9c099290d3e617e03dda3619d"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a26e147a9c099290d3e617e03dda3619d">__xrealloc</a> (void *ptr, size_t size, const char *file, int line, const char *function, const char *var)</td></tr>
<tr class="memdesc:a26e147a9c099290d3e617e03dda3619d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tracked version of realloc().  <br /></td></tr>
<tr class="separator:a26e147a9c099290d3e617e03dda3619d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39788016153b54df3b35aefa562b9e6d" id="r_a39788016153b54df3b35aefa562b9e6d"><td class="memItemLeft" align="right" valign="top">MEMTRACK *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39788016153b54df3b35aefa562b9e6d">__xfind</a> (void *ptr)</td></tr>
<tr class="memdesc:a39788016153b54df3b35aefa562b9e6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search the tracking list for a pointer and return it's information.  <br /></td></tr>
<tr class="separator:a39788016153b54df3b35aefa562b9e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fb3e6eacbda5141d4aa7c2fb0ec048b" id="r_a6fb3e6eacbda5141d4aa7c2fb0ec048b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6fb3e6eacbda5141d4aa7c2fb0ec048b">__xcheck</a> (void *ptr)</td></tr>
<tr class="memdesc:a6fb3e6eacbda5141d4aa7c2fb0ec048b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a buffer wasn't overrun.  <br /></td></tr>
<tr class="separator:a6fb3e6eacbda5141d4aa7c2fb0ec048b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc770c55d160860dca77d400a7349421" id="r_adc770c55d160860dca77d400a7349421"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adc770c55d160860dca77d400a7349421">__xfree</a> (void *ptr)</td></tr>
<tr class="memdesc:adc770c55d160860dca77d400a7349421"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tracked version of free().  <br /></td></tr>
<tr class="separator:adc770c55d160860dca77d400a7349421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eddaa5161bc8f51d3bd599af157786e" id="r_a9eddaa5161bc8f51d3bd599af157786e"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9eddaa5161bc8f51d3bd599af157786e">__xasprintf</a> (const char *file, int line, const char *function, const char *var, const char *format,...)</td></tr>
<tr class="memdesc:a9eddaa5161bc8f51d3bd599af157786e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tracked sprintf replacement that create a new formatted string buffer.  <br /></td></tr>
<tr class="separator:a9eddaa5161bc8f51d3bd599af157786e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add0cb4a42b0f665e302370a23949e2ef" id="r_add0cb4a42b0f665e302370a23949e2ef"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add0cb4a42b0f665e302370a23949e2ef">__xavsprintf</a> (const char *file, int line, const char *function, const char *var, const char *format, va_list va)</td></tr>
<tr class="memdesc:add0cb4a42b0f665e302370a23949e2ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tracked vsprintf replacement that create a new formatted string buffer.  <br /></td></tr>
<tr class="separator:add0cb4a42b0f665e302370a23949e2ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5186a6832c1ecd220353818ee86e92b" id="r_ad5186a6832c1ecd220353818ee86e92b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad5186a6832c1ecd220353818ee86e92b">__xsprintf</a> (char *str, const char *format,...)</td></tr>
<tr class="memdesc:ad5186a6832c1ecd220353818ee86e92b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tracked sprintf replacement.  <br /></td></tr>
<tr class="separator:ad5186a6832c1ecd220353818ee86e92b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9138b9a74b3844f8222931a5e943be2" id="r_af9138b9a74b3844f8222931a5e943be2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af9138b9a74b3844f8222931a5e943be2">__xvsprintf</a> (char *str, const char *format, va_list ap)</td></tr>
<tr class="memdesc:af9138b9a74b3844f8222931a5e943be2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tracked vsprintf replacement.  <br /></td></tr>
<tr class="separator:af9138b9a74b3844f8222931a5e943be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bd00cf414b2a4a848caedcf579ba0d3" id="r_a3bd00cf414b2a4a848caedcf579ba0d3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3bd00cf414b2a4a848caedcf579ba0d3">__xsnprintf</a> (char *str, size_t size, const char *format,...)</td></tr>
<tr class="memdesc:a3bd00cf414b2a4a848caedcf579ba0d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tracked snprintf replacement.  <br /></td></tr>
<tr class="separator:a3bd00cf414b2a4a848caedcf579ba0d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27dc556a8da8fae71b5bd422b224da6b" id="r_a27dc556a8da8fae71b5bd422b224da6b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a27dc556a8da8fae71b5bd422b224da6b">__xvsnprintf</a> (char *str, size_t size, const char *format, va_list ap)</td></tr>
<tr class="memdesc:a27dc556a8da8fae71b5bd422b224da6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tracked vsnprintf replacement.  <br /></td></tr>
<tr class="separator:a27dc556a8da8fae71b5bd422b224da6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d1c23d393fbe104642cbeb6657bb5c" id="r_aa4d1c23d393fbe104642cbeb6657bb5c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa4d1c23d393fbe104642cbeb6657bb5c">__xsprintfcat</a> (char *str, const char *format,...)</td></tr>
<tr class="memdesc:aa4d1c23d393fbe104642cbeb6657bb5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tracked sprintfcat.  <br /></td></tr>
<tr class="separator:aa4d1c23d393fbe104642cbeb6657bb5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cb368b67ad5f14466dfeb867b22b34b" id="r_a0cb368b67ad5f14466dfeb867b22b34b"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0cb368b67ad5f14466dfeb867b22b34b">__xsafesprintf</a> (char *buff, char **bufp, const char *format,...)</td></tr>
<tr class="memdesc:a0cb368b67ad5f14466dfeb867b22b34b"><td class="mdescLeft">&#160;</td><td class="mdescRight">tracked safe_printf replacement.  <br /></td></tr>
<tr class="separator:a0cb368b67ad5f14466dfeb867b22b34b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b57b051694c132b89377727b8e13b77" id="r_a8b57b051694c132b89377727b8e13b77"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b57b051694c132b89377727b8e13b77">__xstrdup</a> (const char *s, const char *file, int line, const char *function, const char *var)</td></tr>
<tr class="memdesc:a8b57b051694c132b89377727b8e13b77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tracked version of strdup.  <br /></td></tr>
<tr class="separator:a8b57b051694c132b89377727b8e13b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f1f39103adbfefeba0d5eb93513cbed" id="r_a2f1f39103adbfefeba0d5eb93513cbed"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f1f39103adbfefeba0d5eb93513cbed">__xstrndup</a> (const char *s, size_t n, const char *file, int line, const char *function, const char *var)</td></tr>
<tr class="memdesc:a2f1f39103adbfefeba0d5eb93513cbed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tracked version of strndup.  <br /></td></tr>
<tr class="separator:a2f1f39103adbfefeba0d5eb93513cbed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adca3e74468323bf8ddb7849a70df4bbc" id="r_adca3e74468323bf8ddb7849a70df4bbc"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adca3e74468323bf8ddb7849a70df4bbc">__xstpcpy</a> (char *dest, const char *src)</td></tr>
<tr class="memdesc:adca3e74468323bf8ddb7849a70df4bbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tracked stpcpy replacement.  <br /></td></tr>
<tr class="separator:adca3e74468323bf8ddb7849a70df4bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9417b17247a548d819a3669c0b849226" id="r_a9417b17247a548d819a3669c0b849226"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9417b17247a548d819a3669c0b849226">__xstrcat</a> (char *dest, const char *src)</td></tr>
<tr class="memdesc:a9417b17247a548d819a3669c0b849226"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tracked strcat replacement.  <br /></td></tr>
<tr class="separator:a9417b17247a548d819a3669c0b849226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38a0486964ed08e7a6bb588d102e44bd" id="r_a38a0486964ed08e7a6bb588d102e44bd"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a38a0486964ed08e7a6bb588d102e44bd">__xstrncat</a> (char *dest, const char *src, size_t n)</td></tr>
<tr class="memdesc:a38a0486964ed08e7a6bb588d102e44bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tracked strncat replacement.  <br /></td></tr>
<tr class="separator:a38a0486964ed08e7a6bb588d102e44bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a250f7ada0235951caf6295a314136674" id="r_a250f7ada0235951caf6295a314136674"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a250f7ada0235951caf6295a314136674">__xstrccat</a> (char *dest, const char src)</td></tr>
<tr class="memdesc:a250f7ada0235951caf6295a314136674"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tracked strccat.  <br /></td></tr>
<tr class="separator:a250f7ada0235951caf6295a314136674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a574198ad95eb4463e7b4db86b01d557c" id="r_a574198ad95eb4463e7b4db86b01d557c"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a574198ad95eb4463e7b4db86b01d557c">__xstrnccat</a> (char *dest, const char src, size_t n)</td></tr>
<tr class="memdesc:a574198ad95eb4463e7b4db86b01d557c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tracked strnccat.  <br /></td></tr>
<tr class="separator:a574198ad95eb4463e7b4db86b01d557c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9104ece64b71e05600a79208b6677aa8" id="r_a9104ece64b71e05600a79208b6677aa8"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9104ece64b71e05600a79208b6677aa8">__xstrcpy</a> (char *dest, const char *src)</td></tr>
<tr class="memdesc:a9104ece64b71e05600a79208b6677aa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tracked strcpy replacement.  <br /></td></tr>
<tr class="separator:a9104ece64b71e05600a79208b6677aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c959544e21eb5cb2ab9d34ba8faab70" id="r_a0c959544e21eb5cb2ab9d34ba8faab70"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c959544e21eb5cb2ab9d34ba8faab70">__xstrncpy</a> (char *dest, const char *src, size_t n)</td></tr>
<tr class="memdesc:a0c959544e21eb5cb2ab9d34ba8faab70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tracked strncpy replacement.  <br /></td></tr>
<tr class="separator:a0c959544e21eb5cb2ab9d34ba8faab70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8292beb4307ea64139167fbf1e376ade" id="r_a8292beb4307ea64139167fbf1e376ade"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8292beb4307ea64139167fbf1e376ade">__xmemmove</a> (void *dest, const void *src, size_t n)</td></tr>
<tr class="memdesc:a8292beb4307ea64139167fbf1e376ade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tracked memmove replacement.  <br /></td></tr>
<tr class="separator:a8292beb4307ea64139167fbf1e376ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2801cb7ba8f4e9d6addd3c284034915f" id="r_a2801cb7ba8f4e9d6addd3c284034915f"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2801cb7ba8f4e9d6addd3c284034915f">__xmempcpy</a> (void *dest, const void *src, size_t n)</td></tr>
<tr class="memdesc:a2801cb7ba8f4e9d6addd3c284034915f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tracked mempcpy replacement.  <br /></td></tr>
<tr class="separator:a2801cb7ba8f4e9d6addd3c284034915f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08fe20af562622dde1da6f9807b01d7c" id="r_a08fe20af562622dde1da6f9807b01d7c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08fe20af562622dde1da6f9807b01d7c">__xmemccpy</a> (void *dest, const void *src, int c, size_t n)</td></tr>
<tr class="memdesc:a08fe20af562622dde1da6f9807b01d7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tracked memccpy replacement.  <br /></td></tr>
<tr class="separator:a08fe20af562622dde1da6f9807b01d7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a674aa4e05a0889774b79f127249f3fb0" id="r_a674aa4e05a0889774b79f127249f3fb0"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a674aa4e05a0889774b79f127249f3fb0">__xmemset</a> (void *s, int c, size_t n)</td></tr>
<tr class="memdesc:a674aa4e05a0889774b79f127249f3fb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tracked memset replacement.  <br /></td></tr>
<tr class="separator:a674aa4e05a0889774b79f127249f3fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d6cfa8b91a91fe02e1bddca20373b8f" id="r_a1d6cfa8b91a91fe02e1bddca20373b8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d6cfa8b91a91fe02e1bddca20373b8f">list_bufstats</a> (dbref player)</td></tr>
<tr class="memdesc:a1d6cfa8b91a91fe02e1bddca20373b8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function placeholder. Not used for now.  <br /></td></tr>
<tr class="separator:a1d6cfa8b91a91fe02e1bddca20373b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af869c3f4f024fdc545fbb58d4c498ae4" id="r_af869c3f4f024fdc545fbb58d4c498ae4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af869c3f4f024fdc545fbb58d4c498ae4">list_buftrace</a> (dbref player)</td></tr>
<tr class="memdesc:af869c3f4f024fdc545fbb58d4c498ae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function placeholder. Not used for now.  <br /></td></tr>
<tr class="separator:af869c3f4f024fdc545fbb58d4c498ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4ba162800be1e1832fd6316dd458590" id="r_aa4ba162800be1e1832fd6316dd458590"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa4ba162800be1e1832fd6316dd458590">__xsorttrace</a> (const void *p1, const void *p2)</td></tr>
<tr class="memdesc:aa4ba162800be1e1832fd6316dd458590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to sort the trace table.  <br /></td></tr>
<tr class="separator:aa4ba162800be1e1832fd6316dd458590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f3880a920752ac225497297ccbdf4a" id="r_a29f3880a920752ac225497297ccbdf4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a29f3880a920752ac225497297ccbdf4a">list_rawmemory</a> (dbref player)</td></tr>
<tr class="memdesc:a29f3880a920752ac225497297ccbdf4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Show to the player a summary of all allocations.  <br /></td></tr>
<tr class="separator:a29f3880a920752ac225497297ccbdf4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61a069393801244ea12e6842c8661650" id="r_a61a069393801244ea12e6842c8661650"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a61a069393801244ea12e6842c8661650">total_rawmemory</a> (void)</td></tr>
<tr class="memdesc:a61a069393801244ea12e6842c8661650"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the total size of all allocations.  <br /></td></tr>
<tr class="separator:a61a069393801244ea12e6842c8661650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbbf8898a2d02a4dff693747bf9bc058" id="r_adbbf8898a2d02a4dff693747bf9bc058"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adbbf8898a2d02a4dff693747bf9bc058">__xsafestrncpy</a> (char *dest, char **destp, const char *src, size_t n, size_t size)</td></tr>
<tr class="memdesc:adbbf8898a2d02a4dff693747bf9bc058"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a string with at most n character from src and update the position pointer to the end of the destination buffer.  <br /></td></tr>
<tr class="separator:adbbf8898a2d02a4dff693747bf9bc058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20c26818e6d772f62fbb5c5a5c8ca23d" id="r_a20c26818e6d772f62fbb5c5a5c8ca23d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a20c26818e6d772f62fbb5c5a5c8ca23d">__xsafestrcatchr</a> (char *dest, char **destp, char c, size_t size)</td></tr>
<tr class="memdesc:a20c26818e6d772f62fbb5c5a5c8ca23d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy char 'c' to dest and update the position pointer to the end of the destination buffer.  <br /></td></tr>
<tr class="separator:a20c26818e6d772f62fbb5c5a5c8ca23d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d7676d25de1ebac84446bdc833b9eea" id="r_a3d7676d25de1ebac84446bdc833b9eea"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d7676d25de1ebac84446bdc833b9eea">__xsafestrncat</a> (char *dest, char **destp, const char *src, size_t n, size_t size)</td></tr>
<tr class="memdesc:a3d7676d25de1ebac84446bdc833b9eea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate two string with at most n character from src and update the position pointer to the end of the destination buffer.  <br /></td></tr>
<tr class="separator:a3d7676d25de1ebac84446bdc833b9eea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af14e26315160450cf92cbce4d22c9bf1" id="r_af14e26315160450cf92cbce4d22c9bf1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af14e26315160450cf92cbce4d22c9bf1">__xsafeltos</a> (char *dest, char **destp, long num, size_t size)</td></tr>
<tr class="memdesc:af14e26315160450cf92cbce4d22c9bf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a long signed number into string.  <br /></td></tr>
<tr class="separator:af14e26315160450cf92cbce4d22c9bf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae316f07ff16273de9f79821af9067761" id="r_ae316f07ff16273de9f79821af9067761"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae316f07ff16273de9f79821af9067761">__xrepeatchar</a> (size_t size, char c)</td></tr>
<tr class="memdesc:ae316f07ff16273de9f79821af9067761"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a string with 'count' number of 'ch' characters.  <br /></td></tr>
<tr class="separator:ae316f07ff16273de9f79821af9067761"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Tracked memory allocation, leak detection, and buffer safety helpers. </p>
<dl class="section author"><dt>Author</dt><dd>TinyMUSH development team (<a href="https://github.com/TinyMUSH">https://github.com/TinyMUSH</a>) </dd></dl>
<dl class="section version"><dt>Version</dt><dd>4.0</dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>Copyright (C) 1989-2025 TinyMUSH development team. You may distribute under the terms the Artistic License, as specified in the COPYING file. </dd></dl>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a8d8cc38c36dd811f50d5162c9df08b81" name="a8d8cc38c36dd811f50d5162c9df08b81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d8cc38c36dd811f50d5162c9df08b81">&#9670;&#160;</a></span>XLOGALLOC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLOGALLOC</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>z</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em></em></span>...&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keywordflow">if</span> (mushconf.<a class="code hl_variable" href="structconfdata.html#a5241bab417873b6d368b4aa93bca95a5">malloc_logger</a>)               \</div>
<div class="line">    {                                         \</div>
<div class="line">        log_write(x, y, z, s, ##__VA_ARGS__); \</div>
<div class="line">    }</div>
<div class="ttc" id="astructconfdata_html_a5241bab417873b6d368b4aa93bca95a5"><div class="ttname"><a href="structconfdata.html#a5241bab417873b6d368b4aa93bca95a5">confdata::malloc_logger</a></div><div class="ttdeci">int malloc_logger</div><div class="ttdef"><b>Definition</b> typedefs.h:1002</div></div>
</div><!-- fragment --><p>Macros and utilities. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a9eddaa5161bc8f51d3bd599af157786e" name="a9eddaa5161bc8f51d3bd599af157786e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eddaa5161bc8f51d3bd599af157786e">&#9670;&#160;</a></span>__xasprintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * __xasprintf </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>file</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>line</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>function</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tracked sprintf replacement that create a new formatted string buffer. </p>
<p>String functions </p>
<p>Much like sprintf, but create a new buffer sized for the resulting string. Memory for the new string is tracked, and must be freed with <a class="el" href="#adc770c55d160860dca77d400a7349421" title="Tracked version of free().">__xfree()</a>.</p>
<p>Do not call this directly, use the wrapper macro XSPRINTF(const char *var, const char *format, ...) that will fill most of the banks for you.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>Filename where the allocation is done. </td></tr>
    <tr><td class="paramname">line</td><td>Line number where the allocation is done. </td></tr>
    <tr><td class="paramname">function</td><td>Function where the allocation is done. </td></tr>
    <tr><td class="paramname">var</td><td>Name of the variable that will receive the pointer (not the variable itself). </td></tr>
    <tr><td class="paramname">format</td><td>Format string. </td></tr>
    <tr><td class="paramname">...</td><td>Variables arguments for the format string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>char* Pointer to the new string buffer. </dd></dl>

</div>
</div>
<a id="add0cb4a42b0f665e302370a23949e2ef" name="add0cb4a42b0f665e302370a23949e2ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add0cb4a42b0f665e302370a23949e2ef">&#9670;&#160;</a></span>__xavsprintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * __xavsprintf </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>file</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>line</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>function</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list</td>          <td class="paramname"><span class="paramname"><em>va</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tracked vsprintf replacement that create a new formatted string buffer. </p>
<p>Much like vsprintf, but create a new buffer sized for the resulting string. Memory for the new string is tracked, and must be freed with <a class="el" href="#adc770c55d160860dca77d400a7349421" title="Tracked version of free().">__xfree()</a>.</p>
<p>Do not call this directly, use the wrapper macro XAVSPRINTF(const char *var, const char *format, ...) that will fill most of the banks for you.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>Filename where the allocation is done. </td></tr>
    <tr><td class="paramname">line</td><td>Line number where the allocation is done. </td></tr>
    <tr><td class="paramname">function</td><td>Function where the allocation is done. </td></tr>
    <tr><td class="paramname">var</td><td>Name of the variable that will receive the pointer (not the variable itself). </td></tr>
    <tr><td class="paramname">format</td><td>Format string. </td></tr>
    <tr><td class="paramname">...</td><td>Variables arguments for the format string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>char* Pointer to the new string buffer. </dd></dl>

</div>
</div>
<a id="aea2258dce7044417ed32c6f8379046a4" name="aea2258dce7044417ed32c6f8379046a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea2258dce7044417ed32c6f8379046a4">&#9670;&#160;</a></span>__xcalloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * __xcalloc </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>nmemb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>file</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>line</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>function</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>var</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tracked version of calloc(). </p>
<p>The <a class="el" href="#aea2258dce7044417ed32c6f8379046a4" title="Tracked version of calloc().">__xcalloc()</a> function allocates memory for an array of nmemb elements of size bytes each and returns a pointer to the allocated memory. The memory is set to zero. If nmemb or size is 0, then calloc() returns NULL. If the multiplication of nmemb and size would result in integer overflow, then <a class="el" href="#aea2258dce7044417ed32c6f8379046a4" title="Tracked version of calloc().">__xcalloc()</a> returns NULL.</p>
<p>This variant checks for integer overflow using SIZE_MAX bounds checking before performing the multiplication to prevent security vulnerabilities.</p>
<p>Do not call this directly, use the wrapper macro XCALLOC(size_t nmemb, size_t size, const char *var) that will fill most of the banks for you.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nmemb</td><td>Number of elements. </td></tr>
    <tr><td class="paramname">size</td><td>Size of each elements. </td></tr>
    <tr><td class="paramname">file</td><td>Filename where the allocation is done. </td></tr>
    <tr><td class="paramname">line</td><td>Line number where the allocation is done. </td></tr>
    <tr><td class="paramname">function</td><td>Function where the allocation is done. </td></tr>
    <tr><td class="paramname">var</td><td>Name of the variable that will receive the pointer (not the variable itself). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void* Pointer to the allocated buffer, or NULL if overflow detected. </dd></dl>
<p>Check for integer overflow: if nmemb &gt; SIZE_MAX / size, then nmemb * size would overflow. We check this before multiplication to avoid undefined behavior.</p>

</div>
</div>
<a id="a6fb3e6eacbda5141d4aa7c2fb0ec048b" name="a6fb3e6eacbda5141d4aa7c2fb0ec048b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fb3e6eacbda5141d4aa7c2fb0ec048b">&#9670;&#160;</a></span>__xcheck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int __xcheck </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a buffer wasn't overrun. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 1, if everything is allright. 0, if buffer overrun, 2 if the buffer isn't track. </dd></dl>

</div>
</div>
<a id="a39788016153b54df3b35aefa562b9e6d" name="a39788016153b54df3b35aefa562b9e6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39788016153b54df3b35aefa562b9e6d">&#9670;&#160;</a></span>__xfind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MEMTRACK * __xfind </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search the tracking list for a pointer and return it's information. </p>
<p>__xfind will search thru all allocated blocks for the address pointed by ptr, if this address is within the start and end of the allocaed block, it will return the MEMTRACK information about that block.</p>
<p>It return NULL if nothing found.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to or somewhere in the allocated memory block. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to a MEMTRACK structure with information on the memory block. or NULL if not found. </dd></dl>

</div>
</div>
<a id="adc770c55d160860dca77d400a7349421" name="adc770c55d160860dca77d400a7349421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc770c55d160860dca77d400a7349421">&#9670;&#160;</a></span>__xfree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int __xfree </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tracked version of free(). </p>
<p>The <a class="el" href="#adc770c55d160860dca77d400a7349421" title="Tracked version of free().">__xfree()</a> function frees the memory space pointed to by ptr, which must have been returned by a previous call to malloc()/__xmalloc(), calloc()/__xcalloc(), or realloc()/__xrealloc(). Otherwise, or if __xfree(ptr) has already been called before, undefined behavior occurs. If ptr is NULL, no operation is performed.</p>
<p>The wrapper macro XFREE(void *ptr) is identical to calling this function directly. Just keep things more redeable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the allocation to be freed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the buffer was tracked and it has been overrun, else 0. </dd></dl>

</div>
</div>
<a id="a3133f65ceaa1203d553920c83380a8c8" name="a3133f65ceaa1203d553920c83380a8c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3133f65ceaa1203d553920c83380a8c8">&#9670;&#160;</a></span>__xmalloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * __xmalloc </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>file</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>line</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>function</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>var</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tracked version of malloc(). </p>
<p>Allocation functions </p>
<p>The <a class="el" href="#a3133f65ceaa1203d553920c83380a8c8" title="Tracked version of malloc().">__xmalloc()</a> function allocates size bytes and returns a pointer to the allocated memory. The memory is set to zero. If size is 0, then malloc() returns NULL.</p>
<p>This variant doesn't check if the multiplication of nmemb and size would result in integer overflow, so don't be silly and don't try to allocate more than 18 exabytes of memory (or 4 gigabytes if your still on 32 bits).</p>
<p>Do not call this directly, use the wrapper macro <a class="el" href="macros_8h.html#a1f2dc397904297d0a9ba598093b19976" title="XMALLOC related macros.">XMALLOC(size_t size, const char *var)</a> that will fill most of the banks for you.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Size of memory to allocate. </td></tr>
    <tr><td class="paramname">file</td><td>Filename where the allocation is done. </td></tr>
    <tr><td class="paramname">line</td><td>Line number where the allocation is done. </td></tr>
    <tr><td class="paramname">function</td><td>Function where the allocation is done. </td></tr>
    <tr><td class="paramname">var</td><td>Name of the variable that will receive the pointer (not the variable itself). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void* Pointer to the allocated buffer. </dd></dl>

</div>
</div>
<a id="a08fe20af562622dde1da6f9807b01d7c" name="a08fe20af562622dde1da6f9807b01d7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08fe20af562622dde1da6f9807b01d7c">&#9670;&#160;</a></span>__xmemccpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * __xmemccpy </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tracked memccpy replacement. </p>
<p>The memccpy() function copies no more than n bytes from memory area src to memory area dest, stopping when the character c is found. The memory areas may overlap: copying takes place as though the bytes in src are first copied into a temporary array that does not overlap src or dest, and the bytes are then copied from the temporary array to dest.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Pointer to destination buffer. </td></tr>
    <tr><td class="paramname">src</td><td>Pointer to source buffer. </td></tr>
    <tr><td class="paramname">n</td><td>Number of bytes to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the destination buffer. </dd></dl>

</div>
</div>
<a id="a8292beb4307ea64139167fbf1e376ade" name="a8292beb4307ea64139167fbf1e376ade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8292beb4307ea64139167fbf1e376ade">&#9670;&#160;</a></span>__xmemmove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * __xmemmove </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tracked memmove replacement. </p>
<p>The <a class="el" href="#a8292beb4307ea64139167fbf1e376ade" title="Tracked memmove replacement.">__xmemmove()</a> function copies n bytes from memory area src to memory area dest. The memory areas may overlap: copying takes place as though the bytes in src are first copied into a temporary array that does not overlap src or dest, and the bytes are then copied from the temporary array to dest.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Pointer to destination buffer. </td></tr>
    <tr><td class="paramname">src</td><td>Pointer to source buffer. </td></tr>
    <tr><td class="paramname">n</td><td>Number of bytes to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the destination buffer. </dd></dl>

</div>
</div>
<a id="a2801cb7ba8f4e9d6addd3c284034915f" name="a2801cb7ba8f4e9d6addd3c284034915f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2801cb7ba8f4e9d6addd3c284034915f">&#9670;&#160;</a></span>__xmempcpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * __xmempcpy </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tracked mempcpy replacement. </p>
<p>The <a class="el" href="#a2801cb7ba8f4e9d6addd3c284034915f" title="Tracked mempcpy replacement.">__xmempcpy()</a> function is nearly identical to the memcpy(3) function. It copies n bytes from the object beginning at src into the object pointed to by dest. But instead of returning the value of dest it returns a pointer to the byte following the last written byte. The memory areas may overlap: copying takes place as though the bytes in src are first copied into a temporary array that does not overlap src or dest, and the bytes are then copied from the temporary array to dest.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Pointer to destination buffer. </td></tr>
    <tr><td class="paramname">src</td><td>Pointer to source buffer. </td></tr>
    <tr><td class="paramname">n</td><td>Number of bytes to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the byte following the last written byte. </dd></dl>

</div>
</div>
<a id="a674aa4e05a0889774b79f127249f3fb0" name="a674aa4e05a0889774b79f127249f3fb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a674aa4e05a0889774b79f127249f3fb0">&#9670;&#160;</a></span>__xmemset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * __xmemset </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tracked memset replacement. </p>
<p>The <a class="el" href="#a674aa4e05a0889774b79f127249f3fb0" title="Tracked memset replacement.">__xmemset()</a> function fills the first n bytes of the memory area pointed to by s with the constant byte c. For tracked allocation, make sure that the buffer does not overrun.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Pointer to the memory area to fill. </td></tr>
    <tr><td class="paramname">c</td><td>Character to fill with. </td></tr>
    <tr><td class="paramname">n</td><td>Size of the memory area to fill. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the memory area. </dd></dl>

</div>
</div>
<a id="a26e147a9c099290d3e617e03dda3619d" name="a26e147a9c099290d3e617e03dda3619d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26e147a9c099290d3e617e03dda3619d">&#9670;&#160;</a></span>__xrealloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * __xrealloc </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>file</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>line</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>function</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>var</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tracked version of realloc(). </p>
<p>The <a class="el" href="#a26e147a9c099290d3e617e03dda3619d" title="Tracked version of realloc().">__xrealloc()</a> function changes the size of the memory block pointed to by ptr to size bytes. The contents will be unchanged in the range from the start of the region up to the minimum of the old and new sizes. If the new size is larger than the old size, the added memory will not be initialized. If ptr is NULL, then the call is equivalent to malloc(size), for all values of size; if size is equal to zero, and ptr is not NULL, then the call is equivalent to free(ptr). Unless ptr is NULL, it must have been returned by an earlier call to malloc(), calloc(), or realloc(). If the area pointed to was moved, a free(ptr) is done.</p>
<p>This variant doesn't check if the multiplication of nmemb and size would result in integer overflow, so don't be silly and don't try to allocate more than 18 exabytes of memory (or 4 gigabytes if your still on 32 bits).</p>
<p>Do not call this directly, use the wrapper macro XREALLOC(void *ptr, size_t size, const char *var) that will fill most of the banks for you.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the allocation to be resize. </td></tr>
    <tr><td class="paramname">size</td><td>Size of memory to allocate. </td></tr>
    <tr><td class="paramname">file</td><td>Filename where the allocation is done. </td></tr>
    <tr><td class="paramname">line</td><td>Line number where the allocation is done. </td></tr>
    <tr><td class="paramname">function</td><td>Function where the allocation is done. </td></tr>
    <tr><td class="paramname">var</td><td>Name of the variable that will receive the pointer (not the variable itself). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void* Pointer to the allocated buffer. </dd></dl>

</div>
</div>
<a id="ae316f07ff16273de9f79821af9067761" name="ae316f07ff16273de9f79821af9067761"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae316f07ff16273de9f79821af9067761">&#9670;&#160;</a></span>__xrepeatchar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * __xrepeatchar </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a string with 'count' number of 'ch' characters. </p>
<p>It is the responsibility of the caller to free the resulting buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Size of the string to build. </td></tr>
    <tr><td class="paramname">c</td><td>Character to fill the string with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the build string. </dd></dl>

</div>
</div>
<a id="af14e26315160450cf92cbce4d22c9bf1" name="af14e26315160450cf92cbce4d22c9bf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af14e26315160450cf92cbce4d22c9bf1">&#9670;&#160;</a></span>__xsafeltos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void __xsafeltos </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>destp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>num</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a long signed number into string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Pointer to destination buffer. </td></tr>
    <tr><td class="paramname">destp</td><td>Pointer tracking the desstination buffer. </td></tr>
    <tr><td class="paramname">num</td><td>Number to convert. </td></tr>
    <tr><td class="paramname">size</td><td>Maximum size of the destination buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0cb368b67ad5f14466dfeb867b22b34b" name="a0cb368b67ad5f14466dfeb867b22b34b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cb368b67ad5f14466dfeb867b22b34b">&#9670;&#160;</a></span>__xsafesprintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * __xsafesprintf </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buff</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>bufp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>tracked safe_printf replacement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buff</td><td>Buffer that will receive the result </td></tr>
    <tr><td class="paramname">bufp</td><td>Pointer to the location in the buffer </td></tr>
    <tr><td class="paramname">format</td><td>Format string. </td></tr>
    <tr><td class="paramname">...</td><td>Variables argument list for the format string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>char* Pointer to buffer </dd></dl>

</div>
</div>
<a id="a20c26818e6d772f62fbb5c5a5c8ca23d" name="a20c26818e6d772f62fbb5c5a5c8ca23d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20c26818e6d772f62fbb5c5a5c8ca23d">&#9670;&#160;</a></span>__xsafestrcatchr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int __xsafestrcatchr </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>destp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy char 'c' to dest and update the position pointer to the end of the destination buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Char to copy </td></tr>
    <tr><td class="paramname">dest</td><td>Pointer to destination buffer. </td></tr>
    <tr><td class="paramname">destp</td><td>Pointer tracking the desstination buffer. </td></tr>
    <tr><td class="paramname">size</td><td>Maximum size of the destination buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3d7676d25de1ebac84446bdc833b9eea" name="a3d7676d25de1ebac84446bdc833b9eea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d7676d25de1ebac84446bdc833b9eea">&#9670;&#160;</a></span>__xsafestrncat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t __xsafestrncat </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>destp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenate two string with at most n character from src and update the position pointer to the end of the destination buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Pointer to destination buffer. </td></tr>
    <tr><td class="paramname">destp</td><td>Pointer tracking the desstination buffer. </td></tr>
    <tr><td class="paramname">src</td><td>Pointer to the string to concatenate. </td></tr>
    <tr><td class="paramname">n</td><td>Maximum number of characters to concatenate. </td></tr>
    <tr><td class="paramname">size</td><td>Maximum size of dest buffer if untracked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of characters that where not copied if the buffer (whichever is smaller) isn't big enough to hold the result. </dd></dl>

</div>
</div>
<a id="adbbf8898a2d02a4dff693747bf9bc058" name="adbbf8898a2d02a4dff693747bf9bc058"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbbf8898a2d02a4dff693747bf9bc058">&#9670;&#160;</a></span>__xsafestrncpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t __xsafestrncpy </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>destp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a string with at most n character from src and update the position pointer to the end of the destination buffer. </p>
<p>Replacement for the safe_* functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Pointer to destination buffer. </td></tr>
    <tr><td class="paramname">destp</td><td>Pointer tracking the desstination buffer. </td></tr>
    <tr><td class="paramname">src</td><td>Pointer to the string to concatenate. </td></tr>
    <tr><td class="paramname">n</td><td>Maximum number of characters to concatenate. </td></tr>
    <tr><td class="paramname">size</td><td>Maximum size of dest buffer if untracked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of characters that where not copied if the buffer (whichever is smaller) isn't big enough to hold the result. </dd></dl>

</div>
</div>
<a id="a3bd00cf414b2a4a848caedcf579ba0d3" name="a3bd00cf414b2a4a848caedcf579ba0d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bd00cf414b2a4a848caedcf579ba0d3">&#9670;&#160;</a></span>__xsnprintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int __xsnprintf </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tracked snprintf replacement. </p>
<p>Like snprintf, but make sure that the buffer does not overflow if the buffer is tracked. Else, act exactly like snprintf.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Buffer where to write the resulting string. </td></tr>
    <tr><td class="paramname">size</td><td>Maximum size to write to the buffer. </td></tr>
    <tr><td class="paramname">format</td><td>Format string. </td></tr>
    <tr><td class="paramname">...</td><td>Variables arguments for the format string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int Number of byte written to the buffer. </dd></dl>

</div>
</div>
<a id="aa4ba162800be1e1832fd6316dd458590" name="aa4ba162800be1e1832fd6316dd458590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4ba162800be1e1832fd6316dd458590">&#9670;&#160;</a></span>__xsorttrace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int __xsorttrace </td>
          <td>(</td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>p1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>p2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to sort the trace table. </p>
<p>This function is used by list_rawmemory for sorting the trace table via qsort()</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>Pointer to the first MEMTRACK struct to compare. </td></tr>
    <tr><td class="paramname">p2</td><td>Pointer to the second MEMTRACK struct to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int Result of the comparison (see man qsort()). </dd></dl>

</div>
</div>
<a id="ad5186a6832c1ecd220353818ee86e92b" name="ad5186a6832c1ecd220353818ee86e92b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5186a6832c1ecd220353818ee86e92b">&#9670;&#160;</a></span>__xsprintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int __xsprintf </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tracked sprintf replacement. </p>
<p>Like sprintf, but make sure that the buffer does not overflow if the buffer is tracked. Else, act exactly like vsprintf.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Buffer where to write the resulting string. </td></tr>
    <tr><td class="paramname">format</td><td>Format string. </td></tr>
    <tr><td class="paramname">...</td><td>Variables argument list for the format string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int Number of byte written to the buffer. </dd></dl>

</div>
</div>
<a id="aa4d1c23d393fbe104642cbeb6657bb5c" name="aa4d1c23d393fbe104642cbeb6657bb5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4d1c23d393fbe104642cbeb6657bb5c">&#9670;&#160;</a></span>__xsprintfcat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int __xsprintfcat </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tracked sprintfcat. </p>
<p>Like sprintf, but append to the buffer and make sure it does not overflow if the buffer is tracked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Buffer where to write the resulting string. </td></tr>
    <tr><td class="paramname">format</td><td>Format string. </td></tr>
    <tr><td class="paramname">...</td><td>Variables argument list for the format string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int Number of byte written to the buffer. </dd></dl>

</div>
</div>
<a id="adca3e74468323bf8ddb7849a70df4bbc" name="adca3e74468323bf8ddb7849a70df4bbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adca3e74468323bf8ddb7849a70df4bbc">&#9670;&#160;</a></span>__xstpcpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * __xstpcpy </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tracked stpcpy replacement. </p>
<p>Copy a string from src to dest, returning a pointer to the end of the resulting string at dest. For tracked allocation, make sure that the destination buffer does not overrun.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Pointer to destination buffer. </td></tr>
    <tr><td class="paramname">src</td><td>Pointer to source buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the end of the string dest (that is, the address of the terminating null byte) rather than the beginning. </dd></dl>

</div>
</div>
<a id="a9417b17247a548d819a3669c0b849226" name="a9417b17247a548d819a3669c0b849226"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9417b17247a548d819a3669c0b849226">&#9670;&#160;</a></span>__xstrcat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * __xstrcat </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tracked strcat replacement. </p>
<p>Append the string src to string dest, returning a pointer to dest. For tracked allocation, make sure that the destination buffer does not overrun.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Pointer to destination buffer. </td></tr>
    <tr><td class="paramname">src</td><td>Pointer to source buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the destination string dest. </dd></dl>

</div>
</div>
<a id="a250f7ada0235951caf6295a314136674" name="a250f7ada0235951caf6295a314136674"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a250f7ada0235951caf6295a314136674">&#9670;&#160;</a></span>__xstrccat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * __xstrccat </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char</td>          <td class="paramname"><span class="paramname"><em>src</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tracked strccat. </p>
<p>Append the character src to string dest, returning a pointer to dest. For tracked allocation, make sure that the destination buffer does not overrun.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Pointer to destination buffer. </td></tr>
    <tr><td class="paramname">src</td><td>Source character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the end of destination string dest. </dd></dl>

</div>
</div>
<a id="a9104ece64b71e05600a79208b6677aa8" name="a9104ece64b71e05600a79208b6677aa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9104ece64b71e05600a79208b6677aa8">&#9670;&#160;</a></span>__xstrcpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * __xstrcpy </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tracked strcpy replacement. </p>
<p>Copy the string src to dest, returning a pointer to dest. For tracked allocation, make sure that the destination buffer does not overrun.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Pointer to destination buffer. </td></tr>
    <tr><td class="paramname">src</td><td>Pointer to source buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the destination string dest. </dd></dl>

</div>
</div>
<a id="a8b57b051694c132b89377727b8e13b77" name="a8b57b051694c132b89377727b8e13b77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b57b051694c132b89377727b8e13b77">&#9670;&#160;</a></span>__xstrdup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * __xstrdup </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>file</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>line</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>function</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>var</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tracked version of strdup. </p>
<p>The <a class="el" href="#a8b57b051694c132b89377727b8e13b77" title="Tracked version of strdup.">__xstrdup()</a> function returns a pointer to a new string which is a duplicate of the string s. Memory for the new string is tracked, and must be freed with <a class="el" href="#adc770c55d160860dca77d400a7349421" title="Tracked version of free().">__xfree()</a>.</p>
<p>Do not call this directly, use the wrapper macro XSTRDUP(const char *str, size_t size, const char *var) that will fill most of the banks for you.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>String to duplicate. </td></tr>
    <tr><td class="paramname">file</td><td>Filename where the allocation is done. </td></tr>
    <tr><td class="paramname">line</td><td>Line number where the allocation is done. </td></tr>
    <tr><td class="paramname">function</td><td>Function where the allocation is done. </td></tr>
    <tr><td class="paramname">var</td><td>Name of the variable that will receive the pointer (not the variable itself). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>char* Pointer to the new string buffer. </dd></dl>

</div>
</div>
<a id="a38a0486964ed08e7a6bb588d102e44bd" name="a38a0486964ed08e7a6bb588d102e44bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38a0486964ed08e7a6bb588d102e44bd">&#9670;&#160;</a></span>__xstrncat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * __xstrncat </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tracked strncat replacement. </p>
<p>Append at most n bytes from string src to string dest, returning a pointer to dest. For tracked allocation, make sure that the destination buffer does not overrun.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Pointer to destination buffer. </td></tr>
    <tr><td class="paramname">src</td><td>Pointer to source buffer. </td></tr>
    <tr><td class="paramname">n</td><td>Maximum numbers of characters to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the destination string dest. </dd></dl>

</div>
</div>
<a id="a574198ad95eb4463e7b4db86b01d557c" name="a574198ad95eb4463e7b4db86b01d557c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a574198ad95eb4463e7b4db86b01d557c">&#9670;&#160;</a></span>__xstrnccat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * __xstrnccat </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tracked strnccat. </p>
<p>Append the character src to string dest and limit dest lengt to n, returning a pointer to dest. For tracked allocation, make sure that the destination buffer does not overrun.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Pointer to destination buffer. </td></tr>
    <tr><td class="paramname">src</td><td>Source character. </td></tr>
    <tr><td class="paramname">n</td><td>Maximum length of dest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the end of destination string dest. </dd></dl>

</div>
</div>
<a id="a0c959544e21eb5cb2ab9d34ba8faab70" name="a0c959544e21eb5cb2ab9d34ba8faab70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c959544e21eb5cb2ab9d34ba8faab70">&#9670;&#160;</a></span>__xstrncpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * __xstrncpy </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tracked strncpy replacement. </p>
<p>Copy at most n bytes from string src to dest, returning a pointer to dest. For tracked allocation, make sure that the destination buffer does not overrun.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Pointer to destination buffer. </td></tr>
    <tr><td class="paramname">src</td><td>Pointer to source buffer. </td></tr>
    <tr><td class="paramname">n</td><td>Maximum numbers of characters to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the destination string dest. </dd></dl>

</div>
</div>
<a id="a2f1f39103adbfefeba0d5eb93513cbed" name="a2f1f39103adbfefeba0d5eb93513cbed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f1f39103adbfefeba0d5eb93513cbed">&#9670;&#160;</a></span>__xstrndup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * __xstrndup </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>file</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>line</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>function</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>var</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tracked version of strndup. </p>
<p>The <a class="el" href="#a8b57b051694c132b89377727b8e13b77" title="Tracked version of strdup.">__xstrdup()</a> function returns a pointer to a new string which is a duplicate of the string s. Memory for the new string is tracked, and must be freed with <a class="el" href="#adc770c55d160860dca77d400a7349421" title="Tracked version of free().">__xfree()</a>.</p>
<p>Do not call this directly, use the wrapper macro XSTRDUP(const char *str, size_t size, const char *var) that will fill most of the banks for you.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>String to duplicate. </td></tr>
    <tr><td class="paramname">n</td><td>Number of bytes to replicates. </td></tr>
    <tr><td class="paramname">file</td><td>Filename where the allocation is done. </td></tr>
    <tr><td class="paramname">line</td><td>Line number where the allocation is done. </td></tr>
    <tr><td class="paramname">function</td><td>Function where the allocation is done. </td></tr>
    <tr><td class="paramname">var</td><td>Name of the variable that will receive the pointer (not the variable itself). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>char* Pointer to the new string buffer. </dd></dl>

</div>
</div>
<a id="a27dc556a8da8fae71b5bd422b224da6b" name="a27dc556a8da8fae71b5bd422b224da6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27dc556a8da8fae71b5bd422b224da6b">&#9670;&#160;</a></span>__xvsnprintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int __xvsnprintf </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list</td>          <td class="paramname"><span class="paramname"><em>ap</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tracked vsnprintf replacement. </p>
<p>Like vsnprintf, but make sure that the buffer does not overflow if the buffer is tracked. Else, act exactly like snprintf.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Buffer where to write the resulting string. </td></tr>
    <tr><td class="paramname">size</td><td>Maximum size to write to the buffer. </td></tr>
    <tr><td class="paramname">format</td><td>Format string. </td></tr>
    <tr><td class="paramname">ap</td><td>Variables argument list for the format string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int Number of byte written to the buffer. </dd></dl>

</div>
</div>
<a id="af9138b9a74b3844f8222931a5e943be2" name="af9138b9a74b3844f8222931a5e943be2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9138b9a74b3844f8222931a5e943be2">&#9670;&#160;</a></span>__xvsprintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int __xvsprintf </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list</td>          <td class="paramname"><span class="paramname"><em>ap</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tracked vsprintf replacement. </p>
<p>Like vsprintf, but make sure that the buffer does not overflow if the buffer is tracked. Else, act exactly like vsprintf.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Buffer where to write the resulting string. </td></tr>
    <tr><td class="paramname">format</td><td>Format string. </td></tr>
    <tr><td class="paramname">ap</td><td>Variables argument list for the format string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int Number of byte written to the buffer. </dd></dl>

</div>
</div>
<a id="a1d6cfa8b91a91fe02e1bddca20373b8f" name="a1d6cfa8b91a91fe02e1bddca20373b8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d6cfa8b91a91fe02e1bddca20373b8f">&#9670;&#160;</a></span>list_bufstats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void list_bufstats </td>
          <td>(</td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>player</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function placeholder. Not used for now. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">player</td><td>dbref of the player who did the command </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af869c3f4f024fdc545fbb58d4c498ae4" name="af869c3f4f024fdc545fbb58d4c498ae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af869c3f4f024fdc545fbb58d4c498ae4">&#9670;&#160;</a></span>list_buftrace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void list_buftrace </td>
          <td>(</td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>player</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function placeholder. Not used for now. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">player</td><td>dbref of the player who did the command </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a29f3880a920752ac225497297ccbdf4a" name="a29f3880a920752ac225497297ccbdf4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29f3880a920752ac225497297ccbdf4a">&#9670;&#160;</a></span>list_rawmemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void list_rawmemory </td>
          <td>(</td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>player</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Show to the player a summary of all allocations. </p>
<p>Called by @list raw_memory. This is primary a debug function and may cause lag on a very large game. Use with caution.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">player</td><td>Dbref of the player making the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a61a069393801244ea12e6842c8661650" name="a61a069393801244ea12e6842c8661650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61a069393801244ea12e6842c8661650">&#9670;&#160;</a></span>total_rawmemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t total_rawmemory </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the total size of all allocations. </p>
<dl class="section return"><dt>Returns</dt><dd>size_t Memory usage. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
