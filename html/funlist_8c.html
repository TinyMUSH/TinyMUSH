<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TinyMUSH: src/netmush/funlist.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">TinyMUSH<span id="projectnumber">&#160;3.3</span>
   </div>
   <div id="projectbrief">TinyMUSH Server</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_d49c5bdcdc946239a893bf2d58085e26.html">netmush</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">funlist.c File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>List manipulation built-ins: set operations, joins, sorting, and selection.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;config.h&quot;</code><br />
<code>#include &quot;<a class="el" href="constants_8h_source.html">constants.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="typedefs_8h_source.html">typedefs.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="macros_8h_source.html">macros.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="externs_8h_source.html">externs.h</a>&quot;</code><br />
<code>#include &quot;prototypes.h&quot;</code><br />
<code>#include &lt;ctype.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for funlist.c:</div>
<div class="dyncontent">
<div class="center"><img src="funlist_8c__incl.png" border="0" usemap="#asrc_2netmush_2funlist_8c" alt=""/></div>
<map name="asrc_2netmush_2funlist_8c" id="asrc_2netmush_2funlist_8c">
<area shape="rect" title="List manipulation built&#45;ins: set operations, joins, sorting, and selection." alt="" coords="301,5,444,31"/>
<area shape="rect" title=" " alt="" coords="21,79,86,105"/>
<area shape="poly" title=" " alt="" coords="315,34,102,81,101,76,314,29"/>
<area shape="rect" href="constants_8h.html" title="Global numeric and string constants for flags, limits, and parser tokens." alt="" coords="111,79,199,105"/>
<area shape="poly" title=" " alt="" coords="336,34,207,76,206,71,335,29"/>
<area shape="rect" href="typedefs_8h.html" title="Core typedefs for dbrefs, flags, buffers, and engine data structures." alt="" coords="183,153,263,178"/>
<area shape="poly" title=" " alt="" coords="338,34,300,53,264,81,245,109,232,139,227,137,240,107,260,77,297,48,336,29"/>
<area shape="rect" href="macros_8h.html" title="Engine&#45;wide macros for memory tracking, flag checks, logging, and utilities." alt="" coords="388,79,463,105"/>
<area shape="poly" title=" " alt="" coords="383,30,410,65,405,68,379,33"/>
<area shape="rect" href="externs_8h.html" title="Shared extern declarations and globals used across the game engine." alt="" coords="486,79,560,105"/>
<area shape="poly" title=" " alt="" coords="399,29,485,70,482,74,397,34"/>
<area shape="rect" href="prototypes_8h_source.html" title=" " alt="" coords="273,79,365,105"/>
<area shape="poly" title=" " alt="" coords="366,33,339,68,335,65,361,30"/>
<area shape="rect" title=" " alt="" coords="584,79,646,105"/>
<area shape="poly" title=" " alt="" coords="414,29,570,74,568,80,413,34"/>
<area shape="rect" title=" " alt="" coords="670,79,733,105"/>
<area shape="poly" title=" " alt="" coords="435,29,656,76,654,81,434,34"/>
<area shape="rect" title=" " alt="" coords="23,153,79,178"/>
<area shape="poly" title=" " alt="" coords="139,107,83,146,80,141,136,103"/>
<area shape="rect" title=" " alt="" coords="97,226,160,252"/>
<area shape="poly" title=" " alt="" coords="209,181,158,219,155,215,205,177"/>
<area shape="rect" title=" " alt="" coords="361,226,421,252"/>
<area shape="poly" title=" " alt="" coords="253,176,349,217,347,222,250,181"/>
<area shape="rect" title=" " alt="" coords="184,226,257,252"/>
<area shape="poly" title=" " alt="" coords="225,179,224,211,219,211,220,178"/>
<area shape="rect" title=" " alt="" coords="282,226,338,252"/>
<area shape="poly" title=" " alt="" coords="239,177,285,214,282,218,236,181"/>
<area shape="rect" title=" " alt="" coords="444,226,524,252"/>
<area shape="poly" title=" " alt="" coords="265,175,430,220,429,225,263,181"/>
<area shape="rect" title=" " alt="" coords="549,226,633,252"/>
<area shape="poly" title=" " alt="" coords="264,173,277,176,534,223,533,229,276,181,263,178"/>
<area shape="poly" title=" " alt="" coords="304,107,253,146,249,141,301,103"/>
<area shape="poly" title=" " alt="" coords="360,103,416,125,441,138,456,151,461,170,455,188,441,205,425,219,421,215,437,201,450,186,456,170,451,154,438,142,414,130,358,108"/>
<area shape="poly" title=" " alt="" coords="366,102,431,124,459,137,477,151,485,165,489,181,491,211,486,211,484,182,480,167,473,154,456,142,429,129,364,108"/>
<area shape="poly" title=" " alt="" coords="366,100,431,119,500,150,541,181,573,213,570,217,538,185,498,155,430,124,365,105"/>
<area shape="rect" title=" " alt="" coords="288,153,350,178"/>
<area shape="poly" title=" " alt="" coords="322,105,322,137,316,137,316,105"/>
<area shape="rect" title=" " alt="" coords="375,153,442,178"/>
<area shape="poly" title=" " alt="" coords="336,103,383,141,380,145,332,107"/>
<area shape="rect" href="ansi_8h_source.html" title=" " alt="" coords="103,153,159,178"/>
<area shape="poly" title=" " alt="" coords="288,108,174,151,172,146,286,103"/>
<area shape="poly" title=" " alt="" coords="133,179,132,211,127,211,128,178"/>
<area shape="poly" title=" " alt="" coords="148,177,195,214,192,219,144,181"/>
<area shape="rect" title=" " alt="" coords="5,226,73,252"/>
<area shape="poly" title=" " alt="" coords="117,181,68,219,65,215,114,177"/>
</map>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:afd761fd92ef9280887064f1c7ae36339" id="r_afd761fd92ef9280887064f1c7ae36339"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd761fd92ef9280887064f1c7ae36339">autodetect_list</a> (char *ptrs[], int nitems)</td></tr>
<tr class="memdesc:afd761fd92ef9280887064f1c7ae36339"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auto-Detect what kind of list we are dealing with.  <br /></td></tr>
<tr class="separator:afd761fd92ef9280887064f1c7ae36339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc4a52e02b81762854b85c67bbfa0801" id="r_abc4a52e02b81762854b85c67bbfa0801"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc4a52e02b81762854b85c67bbfa0801">get_list_type</a> (char *fargs[], int nfargs, int type_pos, char *ptrs[], int nitems)</td></tr>
<tr class="memdesc:abc4a52e02b81762854b85c67bbfa0801"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect the list type.  <br /></td></tr>
<tr class="separator:abc4a52e02b81762854b85c67bbfa0801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac58586c2f7a343dcc079d3c06e3c771d" id="r_ac58586c2f7a343dcc079d3c06e3c771d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac58586c2f7a343dcc079d3c06e3c771d">validate_list_args</a> (const char *func_name, char *buff, char **bufc, dbref player, dbref caller, dbref cause, char *fargs[], int nfargs, char *cargs[], int ncargs, int min_args, int max_args, int delim_pos, int delim_flags, <a class="el" href="structdelim.html">Delim</a> *isep)</td></tr>
<tr class="memdesc:ac58586c2f7a343dcc079d3c06e3c771d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate function arguments and delimiter for list functions.  <br /></td></tr>
<tr class="separator:ac58586c2f7a343dcc079d3c06e3c771d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a736bf9889f910975b364699bc77e9912" id="r_a736bf9889f910975b364699bc77e9912"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a736bf9889f910975b364699bc77e9912">fun_lrand</a> (char *buff, char **bufc, dbref player, dbref caller, dbref cause, char *fargs[], int nfargs, char *cargs[], int ncargs)</td></tr>
<tr class="memdesc:a736bf9889f910975b364699bc77e9912"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a list of random integers within an inclusive range.  <br /></td></tr>
<tr class="separator:a736bf9889f910975b364699bc77e9912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a9efc14d7c5430c6d8a71f715e1f0b4" id="r_a0a9efc14d7c5430c6d8a71f715e1f0b4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a9efc14d7c5430c6d8a71f715e1f0b4">dbnum</a> (char *dbr)</td></tr>
<tr class="memdesc:a0a9efc14d7c5430c6d8a71f715e1f0b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a DBref (<a class="el" href="db__flatfile_8c.html#a81abf5d67af4cc116d290a1d21c750d4">db</a>) to its numerical value (db)  <br /></td></tr>
<tr class="separator:a0a9efc14d7c5430c6d8a71f715e1f0b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a399d38cc7ec52c373af6f5eaa58a4f0a" id="r_a399d38cc7ec52c373af6f5eaa58a4f0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a399d38cc7ec52c373af6f5eaa58a4f0a">fun_words</a> (char *buff, char **bufc, dbref player, dbref caller, dbref cause, char *fargs[], int nfargs, char *cargs[], int ncargs)</td></tr>
<tr class="memdesc:a399d38cc7ec52c373af6f5eaa58a4f0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the words in a list using the specified delimiter.  <br /></td></tr>
<tr class="separator:a399d38cc7ec52c373af6f5eaa58a4f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afabffa26158c77796b8754839acf6dec" id="r_afabffa26158c77796b8754839acf6dec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afabffa26158c77796b8754839acf6dec">fun_first</a> (char *buff, char **bufc, dbref player, dbref caller, dbref cause, char *fargs[], int nfargs, char *cargs[], int ncargs)</td></tr>
<tr class="memdesc:afabffa26158c77796b8754839acf6dec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first word from a list using the given delimiter.  <br /></td></tr>
<tr class="separator:afabffa26158c77796b8754839acf6dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a887cf465a532abdb1d34007750e673e1" id="r_a887cf465a532abdb1d34007750e673e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a887cf465a532abdb1d34007750e673e1">fun_rest</a> (char *buff, char **bufc, dbref player, dbref caller, dbref cause, char *fargs[], int nfargs, char *cargs[], int ncargs)</td></tr>
<tr class="memdesc:a887cf465a532abdb1d34007750e673e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return all words except the first, preserving ANSI state.  <br /></td></tr>
<tr class="separator:a887cf465a532abdb1d34007750e673e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac18dc99ef6e585bd16d5fd590c887437" id="r_ac18dc99ef6e585bd16d5fd590c887437"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac18dc99ef6e585bd16d5fd590c887437">fun_last</a> (char *buff, char **bufc, dbref player, dbref caller, dbref cause, char *fargs[], int nfargs, char *cargs[], int ncargs)</td></tr>
<tr class="memdesc:ac18dc99ef6e585bd16d5fd590c887437"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the last word from a list while preserving ANSI state.  <br /></td></tr>
<tr class="separator:ac18dc99ef6e585bd16d5fd590c887437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bfd4fe1dadf8180ade01e9eb56fd2bf" id="r_a7bfd4fe1dadf8180ade01e9eb56fd2bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7bfd4fe1dadf8180ade01e9eb56fd2bf">fun_match</a> (char *buff, char **bufc, dbref player, dbref caller, dbref cause, char *fargs[], int nfargs, char *cargs[], int ncargs)</td></tr>
<tr class="memdesc:a7bfd4fe1dadf8180ade01e9eb56fd2bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the 1-based index of the first list element matching a pattern.  <br /></td></tr>
<tr class="separator:a7bfd4fe1dadf8180ade01e9eb56fd2bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4070e7333d44adcaf479c9750ea8d2f6" id="r_a4070e7333d44adcaf479c9750ea8d2f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4070e7333d44adcaf479c9750ea8d2f6">fun_matchall</a> (char *buff, char **bufc, dbref player, dbref caller, dbref cause, char *fargs[], int nfargs, char *cargs[], int ncargs)</td></tr>
<tr class="memdesc:a4070e7333d44adcaf479c9750ea8d2f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the indices of all list elements that match (or don't match) a pattern.  <br /></td></tr>
<tr class="separator:a4070e7333d44adcaf479c9750ea8d2f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad386b46f4dbda76ccbcee1e02b59c0cc" id="r_ad386b46f4dbda76ccbcee1e02b59c0cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad386b46f4dbda76ccbcee1e02b59c0cc">fun_extract</a> (char *buff, char **bufc, dbref player, dbref caller, dbref cause, char *fargs[], int nfargs, char *cargs[], int ncargs)</td></tr>
<tr class="memdesc:ad386b46f4dbda76ccbcee1e02b59c0cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a slice of words from a list, with optional output delimiter.  <br /></td></tr>
<tr class="separator:ad386b46f4dbda76ccbcee1e02b59c0cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8bda981b96f4c60217fe07cb39fb538" id="r_ac8bda981b96f4c60217fe07cb39fb538"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac8bda981b96f4c60217fe07cb39fb538">fun_index</a> (char *buff, char **bufc, dbref player, dbref caller, dbref cause, char *fargs[], int nfargs, char *cargs[], int ncargs)</td></tr>
<tr class="memdesc:ac8bda981b96f4c60217fe07cb39fb538"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a substring between occurrences of a single-character separator.  <br /></td></tr>
<tr class="separator:ac8bda981b96f4c60217fe07cb39fb538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abed55c126bbc69593092b5da4cca265c" id="r_abed55c126bbc69593092b5da4cca265c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abed55c126bbc69593092b5da4cca265c">do_itemfuns</a> (char *buff, char **bufc, char *str, int el, char *word, const <a class="el" href="structdelim.html">Delim</a> *sep, int flag)</td></tr>
<tr class="memdesc:abed55c126bbc69593092b5da4cca265c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared worker for ldelete/replace/insert operations on a delimited list.  <br /></td></tr>
<tr class="separator:abed55c126bbc69593092b5da4cca265c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04877225af5d230c44bcccefa200fd3f" id="r_a04877225af5d230c44bcccefa200fd3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a04877225af5d230c44bcccefa200fd3f">fun_ldelete</a> (char *buff, char **bufc, dbref player, dbref caller, dbref cause, char *fargs[], int nfargs, char *cargs[], int ncargs)</td></tr>
<tr class="memdesc:a04877225af5d230c44bcccefa200fd3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a single element from a delimited list.  <br /></td></tr>
<tr class="separator:a04877225af5d230c44bcccefa200fd3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c32426bd8a9d20d39af91fb3dbf1d2" id="r_ab8c32426bd8a9d20d39af91fb3dbf1d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8c32426bd8a9d20d39af91fb3dbf1d2">fun_replace</a> (char *buff, char **bufc, dbref player, dbref caller, dbref cause, char *fargs[], int nfargs, char *cargs[], int ncargs)</td></tr>
<tr class="memdesc:ab8c32426bd8a9d20d39af91fb3dbf1d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace a single list element at a given position.  <br /></td></tr>
<tr class="separator:ab8c32426bd8a9d20d39af91fb3dbf1d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6d17f57a6e06eb8565b180b66dbd1e0" id="r_ab6d17f57a6e06eb8565b180b66dbd1e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab6d17f57a6e06eb8565b180b66dbd1e0">fun_insert</a> (char *buff, char **bufc, dbref player, dbref caller, dbref cause, char *fargs[], int nfargs, char *cargs[], int ncargs)</td></tr>
<tr class="memdesc:ab6d17f57a6e06eb8565b180b66dbd1e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a single element into a delimited list.  <br /></td></tr>
<tr class="separator:ab6d17f57a6e06eb8565b180b66dbd1e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1376f7070128ad17612ce736b31222fc" id="r_a1376f7070128ad17612ce736b31222fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1376f7070128ad17612ce736b31222fc">fun_lreplace</a> (char *buff, char **bufc, dbref player, dbref caller, dbref cause, char *fargs[], int nfargs, char *cargs[], int ncargs)</td></tr>
<tr class="memdesc:a1376f7070128ad17612ce736b31222fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace multiple positions in a list in one call.  <br /></td></tr>
<tr class="separator:a1376f7070128ad17612ce736b31222fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c3396bf0ae29ba67ad3c101e08603cb" id="r_a2c3396bf0ae29ba67ad3c101e08603cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c3396bf0ae29ba67ad3c101e08603cb">fun_remove</a> (char *buff, char **bufc, dbref player, dbref caller, dbref cause, char *fargs[], int nfargs, char *cargs[], int ncargs)</td></tr>
<tr class="memdesc:a2c3396bf0ae29ba67ad3c101e08603cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the first occurrence of a word from a delimited list.  <br /></td></tr>
<tr class="separator:a2c3396bf0ae29ba67ad3c101e08603cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4438048d237ee31a129f0f228a0ab800" id="r_a4438048d237ee31a129f0f228a0ab800"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4438048d237ee31a129f0f228a0ab800">fun_member</a> (char *buff, char **bufc, dbref player, dbref caller, dbref cause, char *fargs[], int nfargs, char *cargs[], int ncargs)</td></tr>
<tr class="memdesc:a4438048d237ee31a129f0f228a0ab800"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the 1-based position of a word in a delimited list.  <br /></td></tr>
<tr class="separator:a4438048d237ee31a129f0f228a0ab800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb5b0169b9dc3315bcd9f9370802e33" id="r_a1cb5b0169b9dc3315bcd9f9370802e33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1cb5b0169b9dc3315bcd9f9370802e33">fun_revwords</a> (char *buff, char **bufc, dbref player, dbref caller, dbref cause, char *fargs[], int nfargs, char *cargs[], int ncargs)</td></tr>
<tr class="memdesc:a1cb5b0169b9dc3315bcd9f9370802e33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse all elements in a delimited list.  <br /></td></tr>
<tr class="separator:a1cb5b0169b9dc3315bcd9f9370802e33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f9bbb01fd4f57b73230da86d8790d43" id="r_a9f9bbb01fd4f57b73230da86d8790d43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f9bbb01fd4f57b73230da86d8790d43">fun_splice</a> (char *buff, char **bufc, dbref player, dbref caller, dbref cause, char *fargs[], int nfargs, char *cargs[], int ncargs)</td></tr>
<tr class="memdesc:a9f9bbb01fd4f57b73230da86d8790d43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge two lists by substituting matching elements from a second list.  <br /></td></tr>
<tr class="separator:a9f9bbb01fd4f57b73230da86d8790d43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91250722db39bebbd4648dcdac63dcb4" id="r_a91250722db39bebbd4648dcdac63dcb4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91250722db39bebbd4648dcdac63dcb4">a_comp</a> (const void *s1, const void *s2)</td></tr>
<tr class="memdesc:a91250722db39bebbd4648dcdac63dcb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">qsort helper for case-sensitive string comparison.  <br /></td></tr>
<tr class="separator:a91250722db39bebbd4648dcdac63dcb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c981d1d7910b295943cc4b57a78624a" id="r_a7c981d1d7910b295943cc4b57a78624a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c981d1d7910b295943cc4b57a78624a">c_comp</a> (const void *s1, const void *s2)</td></tr>
<tr class="memdesc:a7c981d1d7910b295943cc4b57a78624a"><td class="mdescLeft">&#160;</td><td class="mdescRight">qsort helper for case-insensitive string comparison.  <br /></td></tr>
<tr class="separator:a7c981d1d7910b295943cc4b57a78624a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbfe4d9fdd460a6b0f8cda1237132842" id="r_afbfe4d9fdd460a6b0f8cda1237132842"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afbfe4d9fdd460a6b0f8cda1237132842">arec_comp</a> (const void *s1, const void *s2)</td></tr>
<tr class="memdesc:afbfe4d9fdd460a6b0f8cda1237132842"><td class="mdescLeft">&#160;</td><td class="mdescRight">qsort helper for case-sensitive alphanumeric record comparison.  <br /></td></tr>
<tr class="separator:afbfe4d9fdd460a6b0f8cda1237132842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b3f1fe5799b3c0ffd500f3846208074" id="r_a1b3f1fe5799b3c0ffd500f3846208074"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b3f1fe5799b3c0ffd500f3846208074">crec_comp</a> (const void *s1, const void *s2)</td></tr>
<tr class="memdesc:a1b3f1fe5799b3c0ffd500f3846208074"><td class="mdescLeft">&#160;</td><td class="mdescRight">qsort helper for case-insensitive alphanumeric record comparison.  <br /></td></tr>
<tr class="separator:a1b3f1fe5799b3c0ffd500f3846208074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a6082ae23a2a809e08379d545310614" id="r_a1a6082ae23a2a809e08379d545310614"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a6082ae23a2a809e08379d545310614">f_comp</a> (const void *s1, const void *s2)</td></tr>
<tr class="memdesc:a1a6082ae23a2a809e08379d545310614"><td class="mdescLeft">&#160;</td><td class="mdescRight">qsort helper for floating-point record comparison.  <br /></td></tr>
<tr class="separator:a1a6082ae23a2a809e08379d545310614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91f1c5ae9190768259bd48aba1331078" id="r_a91f1c5ae9190768259bd48aba1331078"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91f1c5ae9190768259bd48aba1331078">i_comp</a> (const void *s1, const void *s2)</td></tr>
<tr class="memdesc:a91f1c5ae9190768259bd48aba1331078"><td class="mdescLeft">&#160;</td><td class="mdescRight">qsort helper for integer record comparison.  <br /></td></tr>
<tr class="separator:a91f1c5ae9190768259bd48aba1331078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b49c23eb04930a3813cd6cdd7f92bba" id="r_a0b49c23eb04930a3813cd6cdd7f92bba"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b49c23eb04930a3813cd6cdd7f92bba">do_asort</a> (char *s[], int n, int sort_type, int listpos_only)</td></tr>
<tr class="memdesc:a0b49c23eb04930a3813cd6cdd7f92bba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort a list of strings by the requested type and optionally return positions.  <br /></td></tr>
<tr class="separator:a0b49c23eb04930a3813cd6cdd7f92bba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a725d1511b90dbc467db350295fcc4f84" id="r_a725d1511b90dbc467db350295fcc4f84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a725d1511b90dbc467db350295fcc4f84">handle_sort</a> (char *buff, char **bufc, dbref player, dbref caller, dbref cause, char *fargs[], int nfargs, char *cargs[], int ncargs)</td></tr>
<tr class="memdesc:a725d1511b90dbc467db350295fcc4f84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry point for the <code>sort()</code> family of functions.  <br /></td></tr>
<tr class="separator:a725d1511b90dbc467db350295fcc4f84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a831421e18f2c95ee645246f4f1fb8084" id="r_a831421e18f2c95ee645246f4f1fb8084"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a831421e18f2c95ee645246f4f1fb8084">u_comp</a> (const void *s1, const void *s2, char *cbuff, dbref thing, dbref player, dbref cause)</td></tr>
<tr class="memdesc:a831421e18f2c95ee645246f4f1fb8084"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke a user-provided comparison expression for sorting.  <br /></td></tr>
<tr class="separator:a831421e18f2c95ee645246f4f1fb8084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fcf885c29460d3bbbf1b5fcd6ebe37a" id="r_a4fcf885c29460d3bbbf1b5fcd6ebe37a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4fcf885c29460d3bbbf1b5fcd6ebe37a">sane_qsort</a> (void *array[], int left, int right, int(*compare)(const void *, const void *, char *, dbref, dbref, dbref), char *cbuff, dbref thing, dbref player, dbref cause)</td></tr>
<tr class="memdesc:a4fcf885c29460d3bbbf1b5fcd6ebe37a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Andrew Molitor's quicksort variant tolerant of non-transitive comparators.  <br /></td></tr>
<tr class="separator:a4fcf885c29460d3bbbf1b5fcd6ebe37a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d5f84996e37d6b24287879e97154151" id="r_a4d5f84996e37d6b24287879e97154151"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4d5f84996e37d6b24287879e97154151">fun_sortby</a> (char *buff, char **bufc, dbref player, dbref caller, dbref cause, char *fargs[], int nfargs, char *cargs[], int ncargs)</td></tr>
<tr class="memdesc:a4d5f84996e37d6b24287879e97154151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort a list using a user-supplied comparison expression.  <br /></td></tr>
<tr class="separator:a4d5f84996e37d6b24287879e97154151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17d4796833018312b3f2ce96fb9f7097" id="r_a17d4796833018312b3f2ce96fb9f7097"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a17d4796833018312b3f2ce96fb9f7097">handle_sets</a> (char *buff, char **bufc, dbref player, dbref caller, dbref cause, char *fargs[], int nfargs, char *cargs[], int ncargs)</td></tr>
<tr class="separator:a17d4796833018312b3f2ce96fb9f7097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac416cfbb02d03793a584a7afca88c6e0" id="r_ac416cfbb02d03793a584a7afca88c6e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac416cfbb02d03793a584a7afca88c6e0">fun_columns</a> (char *buff, char **bufc, dbref player, dbref caller, dbref cause, char *fargs[], int nfargs, char *cargs[], int ncargs)</td></tr>
<tr class="memdesc:ac416cfbb02d03793a584a7afca88c6e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format a list into fixed-width columns, preserving ANSI color state.  <br /></td></tr>
<tr class="separator:ac416cfbb02d03793a584a7afca88c6e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6e7f7ec7db9654cb135bc77e8f93a19" id="r_ad6e7f7ec7db9654cb135bc77e8f93a19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad6e7f7ec7db9654cb135bc77e8f93a19">tables_helper</a> (char *list, <a class="el" href="structColorState.html">ColorState</a> *last_state, int n_cols, int col_widths[], char *lead_str, char *trail_str, const <a class="el" href="structdelim.html">Delim</a> *list_sep, const <a class="el" href="structdelim.html">Delim</a> *field_sep, const <a class="el" href="structdelim.html">Delim</a> *pad_char, char *buff, char **bufc, int just)</td></tr>
<tr class="memdesc:ad6e7f7ec7db9654cb135bc77e8f93a19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function for perform_tables.  <br /></td></tr>
<tr class="separator:ad6e7f7ec7db9654cb135bc77e8f93a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f788e9a229c89a36b693b40cf72a858" id="r_a6f788e9a229c89a36b693b40cf72a858"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f788e9a229c89a36b693b40cf72a858">perform_tables</a> (dbref player, char *list, int n_cols, int col_widths[], char *lead_str, char *trail_str, const <a class="el" href="structdelim.html">Delim</a> *list_sep, const <a class="el" href="structdelim.html">Delim</a> *field_sep, const <a class="el" href="structdelim.html">Delim</a> *pad_char, char *buff, char **bufc, int just)</td></tr>
<tr class="memdesc:a6f788e9a229c89a36b693b40cf72a858"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a table.  <br /></td></tr>
<tr class="separator:a6f788e9a229c89a36b693b40cf72a858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe771c8fccab772353340ae9fe3f9b19" id="r_afe771c8fccab772353340ae9fe3f9b19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe771c8fccab772353340ae9fe3f9b19">process_tables</a> (char *buff, char **bufc, dbref player, dbref caller, dbref cause, char *fargs[], int nfargs, char *cargs[], int ncargs)</td></tr>
<tr class="memdesc:afe771c8fccab772353340ae9fe3f9b19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate that we have everything to draw the table.  <br /></td></tr>
<tr class="separator:afe771c8fccab772353340ae9fe3f9b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad83c666b9ec5aca8f4d0cd35a21c6bb9" id="r_ad83c666b9ec5aca8f4d0cd35a21c6bb9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad83c666b9ec5aca8f4d0cd35a21c6bb9">fun_table</a> (char *buff, char **bufc, dbref player, dbref caller, dbref cause, char *fargs[], int nfargs, char *cargs[], int ncargs)</td></tr>
<tr class="memdesc:ad83c666b9ec5aca8f4d0cd35a21c6bb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn a list into a table.  <br /></td></tr>
<tr class="separator:ad83c666b9ec5aca8f4d0cd35a21c6bb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7717c552cbbac09f34e1d22dc3fdcec0" id="r_a7717c552cbbac09f34e1d22dc3fdcec0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7717c552cbbac09f34e1d22dc3fdcec0">fun_elements</a> (char *buff, char **bufc, dbref player, dbref caller, dbref cause, char *fargs[], int nfargs, char *cargs[], int ncargs)</td></tr>
<tr class="memdesc:a7717c552cbbac09f34e1d22dc3fdcec0"><td class="mdescLeft">&#160;</td><td class="mdescRight">given a list of numbers, get corresponding elements from the list.  <br /></td></tr>
<tr class="separator:a7717c552cbbac09f34e1d22dc3fdcec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb9e305043a8eda6c96d7dd9a66c2ca6" id="r_aeb9e305043a8eda6c96d7dd9a66c2ca6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb9e305043a8eda6c96d7dd9a66c2ca6">fun_exclude</a> (char *buff, char **bufc, dbref player, dbref caller, dbref cause, char *fargs[], int nfargs, char *cargs[], int ncargs)</td></tr>
<tr class="memdesc:aeb9e305043a8eda6c96d7dd9a66c2ca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elements of a list EXCEPT the numbered items.  <br /></td></tr>
<tr class="separator:aeb9e305043a8eda6c96d7dd9a66c2ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d712a467bcdaab2c3d591d52316e93e" id="r_a3d712a467bcdaab2c3d591d52316e93e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d712a467bcdaab2c3d591d52316e93e">fun_grab</a> (char *buff, char **bufc, dbref player, dbref caller, dbref cause, char *fargs[], int nfargs, char *cargs[], int ncargs)</td></tr>
<tr class="memdesc:a3d712a467bcdaab2c3d591d52316e93e"><td class="mdescLeft">&#160;</td><td class="mdescRight">a combination of extract() and match(), sortof. We grab the single element that we match.  <br /></td></tr>
<tr class="separator:a3d712a467bcdaab2c3d591d52316e93e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4cce78f64493c19f35a985278538515" id="r_ae4cce78f64493c19f35a985278538515"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae4cce78f64493c19f35a985278538515">fun_graball</a> (char *buff, char **bufc, dbref player, dbref caller, dbref cause, char *fargs[], int nfargs, char *cargs[], int ncargs)</td></tr>
<tr class="memdesc:ae4cce78f64493c19f35a985278538515"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like grab with matchall() rather than match(). We grab all the elements that match, and we can take an output delimiter.  <br /></td></tr>
<tr class="separator:ae4cce78f64493c19f35a985278538515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e1023fafb1c56822364d806974b4a1d" id="r_a3e1023fafb1c56822364d806974b4a1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e1023fafb1c56822364d806974b4a1d">swap</a> (char **p, char **q)</td></tr>
<tr class="memdesc:a3e1023fafb1c56822364d806974b4a1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">swaps two points to strings  <br /></td></tr>
<tr class="separator:a3e1023fafb1c56822364d806974b4a1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a364fff9001481b9ca0eca157f72001" id="r_a0a364fff9001481b9ca0eca157f72001"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a364fff9001481b9ca0eca157f72001">fun_shuffle</a> (char *buff, char **bufc, dbref player, dbref caller, dbref cause, char *fargs[], int nfargs, char *cargs[], int ncargs)</td></tr>
<tr class="memdesc:a0a364fff9001481b9ca0eca157f72001"><td class="mdescLeft">&#160;</td><td class="mdescRight">randomize order of words in a list.  <br /></td></tr>
<tr class="separator:a0a364fff9001481b9ca0eca157f72001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c4c0992e581bd64a8d2429fd6e40d9e" id="r_a0c4c0992e581bd64a8d2429fd6e40d9e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c4c0992e581bd64a8d2429fd6e40d9e">fun_ledit</a> (char *buff, char **bufc, dbref player, dbref caller, dbref cause, char *fargs[], int nfargs, char *cargs[], int ncargs)</td></tr>
<tr class="memdesc:a0c4c0992e581bd64a8d2429fd6e40d9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">If a &lt;word&gt; in </p><ul>
</ul>
<p>in &lt;old words&gt;, replace it with the corresponding word from &lt;new words&gt;. This is basically a mass-edit. This is an EXACT, not a case-insensitive or wildcarded, match.  <br /></td></tr>
<tr class="separator:a0c4c0992e581bd64a8d2429fd6e40d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0028782d1ebb7431ed155344055154fc" id="r_a0028782d1ebb7431ed155344055154fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0028782d1ebb7431ed155344055154fc">fun_itemize</a> (char *buff, char **bufc, dbref player, dbref caller, dbref cause, char *fargs[], int nfargs, char *cargs[], int ncargs)</td></tr>
<tr class="memdesc:a0028782d1ebb7431ed155344055154fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn a list into a punctuated list.  <br /></td></tr>
<tr class="separator:a0028782d1ebb7431ed155344055154fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71ee693823306c3c400b9f85894536fb" id="r_a71ee693823306c3c400b9f85894536fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a71ee693823306c3c400b9f85894536fb">fun_choose</a> (char *buff, char **bufc, dbref player, dbref caller, dbref cause, char *fargs[], int nfargs, char *cargs[], int ncargs)</td></tr>
<tr class="memdesc:a71ee693823306c3c400b9f85894536fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weighted random choice from a list.  <br /></td></tr>
<tr class="separator:a71ee693823306c3c400b9f85894536fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ab3b3320aeedd69d373cb504f85c169" id="r_a6ab3b3320aeedd69d373cb504f85c169"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ab3b3320aeedd69d373cb504f85c169">fun_group</a> (char *buff, char **bufc, dbref player, dbref caller, dbref cause, char *fargs[], int nfargs, char *cargs[], int ncargs)</td></tr>
<tr class="memdesc:a6ab3b3320aeedd69d373cb504f85c169"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort a list by numerical-size group, i.e., take every Nth element. Useful for passing to a column-type function where you want the list to go down rather than across, for instance.  <br /></td></tr>
<tr class="separator:a6ab3b3320aeedd69d373cb504f85c169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa76fe7cff1d8dded21d52750c80e8d75" id="r_aa76fe7cff1d8dded21d52750c80e8d75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa76fe7cff1d8dded21d52750c80e8d75">fun_tokens</a> (char *buff, char **bufc, dbref player, dbref caller, dbref cause, char *fargs[], int nfargs, char *cargs[], int ncargs)</td></tr>
<tr class="memdesc:aa76fe7cff1d8dded21d52750c80e8d75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a string such as 'this "Joe Bloggs" John' and turn it into an output delim-separated list.  <br /></td></tr>
<tr class="separator:aa76fe7cff1d8dded21d52750c80e8d75"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>List manipulation built-ins: set operations, joins, sorting, and selection. </p>
<dl class="section author"><dt>Author</dt><dd>TinyMUSH development team (<a href="https://github.com/TinyMUSH">https://github.com/TinyMUSH</a>) </dd></dl>
<dl class="section version"><dt>Version</dt><dd>4.0</dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>Copyright (C) 1989-2025 TinyMUSH development team. You may distribute under the terms the Artistic License, as specified in the COPYING file. </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a91250722db39bebbd4648dcdac63dcb4" name="a91250722db39bebbd4648dcdac63dcb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91250722db39bebbd4648dcdac63dcb4">&#9670;&#160;</a></span>a_comp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int a_comp </td>
          <td>(</td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>s1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>s2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>qsort helper for case-sensitive string comparison. </p>
<p>Casts <code>s1</code> and <code>s2</code> to <code>const char **</code> and returns the result of <code>strcmp(*s1, *s2)</code>. Suitable for use with <code>qsort</code> over an array of <code>char *</code> pointers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>Pointer to first string pointer </td></tr>
    <tr><td class="paramname">s2</td><td>Pointer to second string pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int Negative if <code>*s1</code> &lt; <code>*s2</code>, zero if equal, positive if <code>*s1</code> &gt; <code>*s2</code> </dd></dl>

</div>
</div>
<a id="afbfe4d9fdd460a6b0f8cda1237132842" name="afbfe4d9fdd460a6b0f8cda1237132842"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbfe4d9fdd460a6b0f8cda1237132842">&#9670;&#160;</a></span>arec_comp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int arec_comp </td>
          <td>(</td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>s1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>s2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>qsort helper for case-sensitive alphanumeric record comparison. </p>
<p>Interprets <code>s1</code> and <code>s2</code> as pointers to <code>A_RECORD</code> and compares their <code>str</code> fields with <code>strcmp</code>. Designed for <code>qsort</code> over arrays of <code>A_RECORD</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>Pointer to first <code>A_RECORD</code> </td></tr>
    <tr><td class="paramname">s2</td><td>Pointer to second <code>A_RECORD</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int Negative if <code>s1-&gt;str</code> &lt; <code>s2-&gt;str</code>, zero if equal, positive if <code>s1-&gt;str</code> &gt; <code>s2-&gt;str</code> </dd></dl>

</div>
</div>
<a id="afd761fd92ef9280887064f1c7ae36339" name="afd761fd92ef9280887064f1c7ae36339"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd761fd92ef9280887064f1c7ae36339">&#9670;&#160;</a></span>autodetect_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int autodetect_list </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>ptrs</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nitems</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auto-Detect what kind of list we are dealing with. </p>
<p>List management utilities. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrs</td><td>List to check </td></tr>
    <tr><td class="paramname">nitems</td><td>Number of items </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int List type (NUMERIC_LIST, FLOAT_LIST, DBREF_LIST, or ALPHANUM_LIST)</dd></dl>
<p>Analyzes the list items to determine the appropriate sort type. Starts by assuming numeric, then checks for floats, DBrefs, or falls back to alphanumeric. DBref detection is based on the first item starting with '#' followed by digits. </p>
<p>If non-numeric, switch to alphanum sort. Exception: if this is the first element and it is a good dbref, switch to a dbref sort. We're a little looser than the normal 'good dbref' rules, any number following the #-sign is accepted.</p>

</div>
</div>
<a id="a7c981d1d7910b295943cc4b57a78624a" name="a7c981d1d7910b295943cc4b57a78624a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c981d1d7910b295943cc4b57a78624a">&#9670;&#160;</a></span>c_comp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int c_comp </td>
          <td>(</td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>s1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>s2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>qsort helper for case-insensitive string comparison. </p>
<p>Casts <code>s1</code> and <code>s2</code> to <code>const char **</code> and returns the result of <code>strcasecmp(*s1, *s2)</code>. Suitable for use with <code>qsort</code> over an array of <code>char *</code> pointers when ASCII case folding is desired.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>Pointer to first string pointer </td></tr>
    <tr><td class="paramname">s2</td><td>Pointer to second string pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int Negative if <code>*s1</code> &lt; <code>*s2</code>, zero if equal, positive if <code>*s1</code> &gt; <code>*s2</code> </dd></dl>

</div>
</div>
<a id="a1b3f1fe5799b3c0ffd500f3846208074" name="a1b3f1fe5799b3c0ffd500f3846208074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b3f1fe5799b3c0ffd500f3846208074">&#9670;&#160;</a></span>crec_comp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crec_comp </td>
          <td>(</td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>s1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>s2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>qsort helper for case-insensitive alphanumeric record comparison. </p>
<p>Interprets <code>s1</code> and <code>s2</code> as pointers to <code>A_RECORD</code> and compares their <code>str</code> fields with <code>strcasecmp</code> for ASCII case folding. Designed for <code>qsort</code> over arrays of <code>A_RECORD</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>Pointer to first <code>A_RECORD</code> </td></tr>
    <tr><td class="paramname">s2</td><td>Pointer to second <code>A_RECORD</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int Negative if <code>s1-&gt;str</code> &lt; <code>s2-&gt;str</code>, zero if equal, positive if <code>s1-&gt;str</code> &gt; <code>s2-&gt;str</code> </dd></dl>

</div>
</div>
<a id="a0a9efc14d7c5430c6d8a71f715e1f0b4" name="a0a9efc14d7c5430c6d8a71f715e1f0b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a9efc14d7c5430c6d8a71f715e1f0b4">&#9670;&#160;</a></span>dbnum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int dbnum </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dbr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a DBref (<a class="el" href="db__flatfile_8c.html#a81abf5d67af4cc116d290a1d21c750d4">db</a>) to its numerical value (db) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dbr</td><td>Text DBref value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int DBref numerical value </dd></dl>

</div>
</div>
<a id="a0b49c23eb04930a3813cd6cdd7f92bba" name="a0b49c23eb04930a3813cd6cdd7f92bba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b49c23eb04930a3813cd6cdd7f92bba">&#9670;&#160;</a></span>do_asort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int * do_asort </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>s</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>sort_type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>listpos_only</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort a list of strings by the requested type and optionally return positions. </p>
<p>Sorts the array <code>s</code> of length <code>n</code> using <code>sort_type:</code> ALPHANUM_LIST and NOCASE_LIST apply string comparison (case-sensitive/insensitive), NUMERIC_LIST parses integers, DBREF_LIST sorts by <code><a class="el" href="#a0a9efc14d7c5430c6d8a71f715e1f0b4" title="Convert a DBref (db) to its numerical value (db)">dbnum()</a></code>, and FLOAT_LIST parses doubles. When <code>listpos_only</code> is zero, <code>s</code> is sorted in place. When non-zero, a 1-based position array is returned indicating each element's original index in sorted order. For ALPHANUM_LIST and NOCASE_LIST the input array is left untouched when <code>listpos_only</code> is non-zero; other modes still reorder <code>s</code> while also returning positions. Caller must free the returned array (if non-NULL) with <code>XFREE</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Array of list elements to sort (modified unless ALPHANUM/NOCASE with listpos_only set) </td></tr>
    <tr><td class="paramname">n</td><td>Number of elements in <code>s</code> </td></tr>
    <tr><td class="paramname">sort_type</td><td>Sort strategy selector (ALPHANUM_LIST, NOCASE_LIST, NUMERIC_LIST, DBREF_LIST, FLOAT_LIST) </td></tr>
    <tr><td class="paramname">listpos_only</td><td>Non-zero to return original positions instead of (or in addition to) an in-place sort </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int* Position array mapping sorted order to original 1-based indices, or NULL if not requested </dd></dl>

</div>
</div>
<a id="abed55c126bbc69593092b5da4cca265c" name="abed55c126bbc69593092b5da4cca265c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abed55c126bbc69593092b5da4cca265c">&#9670;&#160;</a></span>do_itemfuns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void do_itemfuns </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buff</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>bufc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>el</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>word</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdelim.html">Delim</a> *</td>          <td class="paramname"><span class="paramname"><em>sep</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>flag</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shared worker for ldelete/replace/insert operations on a delimited list. </p>
<p>Splits <code>str</code> into before/target/after chunks using <code>sep</code>, then performs one of:</p><ul>
<li>IF_DELETE: drop the target element and join the rest.</li>
<li>IF_REPLACE: substitute <code>word</code> for the target element.</li>
<li>IF_INSERT: insert <code>word</code> at the target position (allowing append when past end).</li>
</ul>
<p>If <code>str</code> is empty, only IF_INSERT at position 1 produces output. Positions &lt;1 emit the original string unchanged. If the requested element is beyond the end (and not an allowed insert-at-end), the original string is returned. Results are written to <code>buff</code> via <code>bufc</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buff</td><td>Output buffer </td></tr>
    <tr><td class="paramname">bufc</td><td>Output buffer tracker </td></tr>
    <tr><td class="paramname">str</td><td>Input list to modify </td></tr>
    <tr><td class="paramname">el</td><td>1-based target position </td></tr>
    <tr><td class="paramname">word</td><td>Replacement/insert text (ignored for delete) </td></tr>
    <tr><td class="paramname">sep</td><td>Input/output delimiter </td></tr>
    <tr><td class="paramname">flag</td><td>Operation selector: IF_DELETE, IF_REPLACE, or IF_INSERT </td></tr>
  </table>
  </dd>
</dl>
<p>If passed a null string return an empty string, except that we are allowed to append to a null string.</p>
<p>we can't fiddle with anything before the first position</p>
<p>Split the list up into 'before', 'target', and 'after' chunks pointed to by sptr, iptr, and eptr respectively.</p>
<p>No 'before' portion, just split off element 1</p>
<p>Break off 'before' portion</p>
<p>If we didn't make it to the target element, just return the string. Insert is allowed to continue if we are exactly at the end of the string, but replace and delete are not.</p>
<p>Split the 'target' word from the 'after' portion.</p>

</div>
</div>
<a id="a1a6082ae23a2a809e08379d545310614" name="a1a6082ae23a2a809e08379d545310614"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a6082ae23a2a809e08379d545310614">&#9670;&#160;</a></span>f_comp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int f_comp </td>
          <td>(</td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>s1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>s2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>qsort helper for floating-point record comparison. </p>
<p>Interprets <code>s1</code> and <code>s2</code> as pointers to <code>F_RECORD</code> and compares their <code>data</code> fields. Returns 1 when the first value is greater, -1 when smaller, and 0 when equal. Suitable for use with <code>qsort</code> over arrays of <code>F_RECORD</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>Pointer to first <code>F_RECORD</code> </td></tr>
    <tr><td class="paramname">s2</td><td>Pointer to second <code>F_RECORD</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 1 if <code>s1-&gt;data</code> &gt; <code>s2-&gt;data</code>, -1 if less, 0 if equal </dd></dl>

</div>
</div>
<a id="a71ee693823306c3c400b9f85894536fb" name="a71ee693823306c3c400b9f85894536fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71ee693823306c3c400b9f85894536fb">&#9670;&#160;</a></span>fun_choose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fun_choose </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buff</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>bufc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>player</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>caller</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>cause</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>fargs</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nfargs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>cargs</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ncargs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Weighted random choice from a list. </p>
<p>choose(&lt;list of items&gt;,&lt;list of weights&gt;,&lt;input delim&gt;)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buff</td><td>Output buffer </td></tr>
    <tr><td class="paramname">bufc</td><td>Output buffer tracker </td></tr>
    <tr><td class="paramname">player</td><td>DBref of player </td></tr>
    <tr><td class="paramname">caller</td><td>DBref of caller </td></tr>
    <tr><td class="paramname">cause</td><td>DBref of cause </td></tr>
    <tr><td class="paramname">fargs</td><td>Function's arguments </td></tr>
    <tr><td class="paramname">nfargs</td><td>Number of function's arguments </td></tr>
    <tr><td class="paramname">cargs</td><td>Command's arguments </td></tr>
    <tr><td class="paramname">ncargs</td><td>Number of command's arguments </td></tr>
  </table>
  </dd>
</dl>
<p>Store the breakpoints, not the choose weights themselves.</p>

</div>
</div>
<a id="ac416cfbb02d03793a584a7afca88c6e0" name="ac416cfbb02d03793a584a7afca88c6e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac416cfbb02d03793a584a7afca88c6e0">&#9670;&#160;</a></span>fun_columns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fun_columns </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buff</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>bufc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>player</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>caller</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>cause</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>fargs</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nfargs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>cargs</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ncargs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format a list into fixed-width columns, preserving ANSI color state. </p>
<p>Splits the input list on the supplied delimiter, truncates or pads each element to the requested width, and emits ANSI transitions so colored text stays intact across column boundaries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buff</td><td>Output buffer </td></tr>
    <tr><td class="paramname">bufc</td><td>Output buffer tracker </td></tr>
    <tr><td class="paramname">player</td><td>DBref of player </td></tr>
    <tr><td class="paramname">caller</td><td>DBref of caller </td></tr>
    <tr><td class="paramname">cause</td><td>DBref of cause </td></tr>
    <tr><td class="paramname">fargs</td><td>Function's arguments: [0]=list, [1]=column width, [2]=optional delimiter </td></tr>
    <tr><td class="paramname">nfargs</td><td>Number of function's arguments </td></tr>
    <tr><td class="paramname">cargs</td><td>Command's arguments </td></tr>
    <tr><td class="paramname">ncargs</td><td>Number of command's arguments</td></tr>
  </table>
  </dd>
</dl>
<p>Each element is padded or truncated to fit the specified width, and ANSI color states are preserved between elements. </p>
<p>unsigned int, always a positive number</p>
<p>Must check number separately, since number + indent can result in an integer overflow.</p>
<p>We only need spaces if we need to pad out. Sanitize the number of spaces, too.</p>

</div>
</div>
<a id="a7717c552cbbac09f34e1d22dc3fdcec0" name="a7717c552cbbac09f34e1d22dc3fdcec0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7717c552cbbac09f34e1d22dc3fdcec0">&#9670;&#160;</a></span>fun_elements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fun_elements </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buff</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>bufc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>player</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>caller</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>cause</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>fargs</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nfargs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>cargs</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ncargs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>given a list of numbers, get corresponding elements from the list. </p>
<p>elements(ack bar eep foof yay,2 4) ==&gt; bar foof The function takes a separator, but the separator only applies to the first list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buff</td><td>Output buffer </td></tr>
    <tr><td class="paramname">bufc</td><td>Output buffer tracker </td></tr>
    <tr><td class="paramname">player</td><td>DBref of player </td></tr>
    <tr><td class="paramname">caller</td><td>DBref of caller </td></tr>
    <tr><td class="paramname">cause</td><td>DBref of cause </td></tr>
    <tr><td class="paramname">fargs</td><td>Function's arguments </td></tr>
    <tr><td class="paramname">nfargs</td><td>Number of function's arguments </td></tr>
    <tr><td class="paramname">cargs</td><td>Command's arguments </td></tr>
    <tr><td class="paramname">ncargs</td><td>Number of command's arguments </td></tr>
  </table>
  </dd>
</dl>
<p>Turn the first list into an array.</p>
<p>Go through the second list, grabbing the numbers and finding the corresponding elements.</p>
<p>Just a number. If negative, count back from end of list.</p>
<p>Support Python-style slicing syntax: &lt;start&gt;:&lt;end&gt;:&lt;step&gt; If start is empty, start from element 0. If start is positive, start from that number. If start is negative, start from that number back from the end (-1 is the last item, -2 is second to last, etc.) If end is empty, stop at the last element. If end is positive, stop there. If end is negative, skip the last end elements. Note that Python numbers arrays from 0, and we number word lists from 1, so the syntax isn't Python-identical!</p>
<p>r points to our start</p>
<p>Empty start</p>
<p>Empty end</p>
<p>Empty start, goes to the LAST element</p>
<p>Empty end</p>

</div>
</div>
<a id="aeb9e305043a8eda6c96d7dd9a66c2ca6" name="aeb9e305043a8eda6c96d7dd9a66c2ca6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb9e305043a8eda6c96d7dd9a66c2ca6">&#9670;&#160;</a></span>fun_exclude()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fun_exclude </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buff</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>bufc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>player</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>caller</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>cause</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>fargs</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nfargs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>cargs</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ncargs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the elements of a list EXCEPT the numbered items. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buff</td><td>Output buffer </td></tr>
    <tr><td class="paramname">bufc</td><td>Output buffer tracker </td></tr>
    <tr><td class="paramname">player</td><td>DBref of player </td></tr>
    <tr><td class="paramname">caller</td><td>DBref of caller </td></tr>
    <tr><td class="paramname">cause</td><td>DBref of cause </td></tr>
    <tr><td class="paramname">fargs</td><td>Function's arguments </td></tr>
    <tr><td class="paramname">nfargs</td><td>Number of function's arguments </td></tr>
    <tr><td class="paramname">cargs</td><td>Command's arguments </td></tr>
    <tr><td class="paramname">ncargs</td><td>Number of command's arguments </td></tr>
  </table>
  </dd>
</dl>
<p>Turn the first list into an array.</p>
<p>Go through the second list, grabbing the numbers and mapping the corresponding elements.</p>
<p>Just a number. If negative, count back from end of list.</p>
<p>Slicing syntax</p>
<p>r points to our start</p>
<p>Empty start</p>
<p>Empty end</p>
<p>Empty start, goes to the LAST element</p>
<p>Empty end</p>

</div>
</div>
<a id="ad386b46f4dbda76ccbcee1e02b59c0cc" name="ad386b46f4dbda76ccbcee1e02b59c0cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad386b46f4dbda76ccbcee1e02b59c0cc">&#9670;&#160;</a></span>fun_extract()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fun_extract </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buff</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>bufc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>player</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>caller</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>cause</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>fargs</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nfargs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>cargs</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ncargs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract a slice of words from a list, with optional output delimiter. </p>
<p>Splits <code>fargs</code>[0] on the input delimiter (default space). Starting at 1-based position <code>fargs</code>[1], copies <code>fargs</code>[2] words to <code>buff</code>. If <code>fargs</code>[4] is given, it is used as the output delimiter; otherwise the input delimiter is reused. When input and output delimiters match, the function copies the substring directly for efficiency; otherwise it rebuilds the slice token by token. If <code>start</code> or <code>len</code> is less than 1, or the start position is past the end of the list, an empty string is returned. Argument validation errors are written to <code>buff</code> by the range and delimiter checks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buff</td><td>Output buffer </td></tr>
    <tr><td class="paramname">bufc</td><td>Output buffer tracker </td></tr>
    <tr><td class="paramname">player</td><td>DBref of player (unused) </td></tr>
    <tr><td class="paramname">caller</td><td>DBref of caller (unused) </td></tr>
    <tr><td class="paramname">cause</td><td>DBref of cause (unused) </td></tr>
    <tr><td class="paramname">fargs</td><td>Function arguments: [0]=list, [1]=start (1-based), [2]=length, [3]=optional input delimiter, [4]=optional output delimiter </td></tr>
    <tr><td class="paramname">nfargs</td><td>Number of function arguments </td></tr>
    <tr><td class="paramname">cargs</td><td>Command arguments (unused) </td></tr>
    <tr><td class="paramname">ncargs</td><td>Number of command arguments (unused) </td></tr>
  </table>
  </dd>
</dl>
<p>Skip to the start of the string to save</p>
<p>If we ran of the end of the string, return nothing</p>
<p>If our delimiter is the same, we have an easy task. Otherwise we have to go token by token.</p>
<p>Count off the words in the string to save</p>
<p>Chop off the rest of the string, if needed</p>

</div>
</div>
<a id="afabffa26158c77796b8754839acf6dec" name="afabffa26158c77796b8754839acf6dec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afabffa26158c77796b8754839acf6dec">&#9670;&#160;</a></span>fun_first()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fun_first </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buff</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>bufc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>player</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>caller</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>cause</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>fargs</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nfargs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>cargs</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ncargs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the first word from a list using the given delimiter. </p>
<p>Trims leading separators, splits <code>fargs</code>[0] on the delimiter (default space if none specified), and copies the first element to <code>buff</code>. With no arguments, returns an empty string without emitting an error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buff</td><td>Output buffer </td></tr>
    <tr><td class="paramname">bufc</td><td>Output buffer tracker </td></tr>
    <tr><td class="paramname">player</td><td>DBref of player (unused) </td></tr>
    <tr><td class="paramname">caller</td><td>DBref of caller (unused) </td></tr>
    <tr><td class="paramname">cause</td><td>DBref of cause (unused) </td></tr>
    <tr><td class="paramname">fargs</td><td>Function arguments: [0]=list, [1]=optional delimiter </td></tr>
    <tr><td class="paramname">nfargs</td><td>Number of function arguments </td></tr>
    <tr><td class="paramname">cargs</td><td>Command arguments (unused) </td></tr>
    <tr><td class="paramname">ncargs</td><td>Number of command arguments (unused) </td></tr>
  </table>
  </dd>
</dl>
<p>If we are passed an empty arglist return a null string</p>

</div>
</div>
<a id="a3d712a467bcdaab2c3d591d52316e93e" name="a3d712a467bcdaab2c3d591d52316e93e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d712a467bcdaab2c3d591d52316e93e">&#9670;&#160;</a></span>fun_grab()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fun_grab </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buff</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>bufc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>player</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>caller</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>cause</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>fargs</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nfargs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>cargs</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ncargs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a combination of extract() and match(), sortof. We grab the single element that we match. </p>
<p>grab(Test:1 Ack:2 Foof:3,&lt;em&gt;:2) =&gt; Ack:2 grab(Test-1+Ack-2+Foof-3,*o,+) =&gt; Ack:2</p>
<p>fun_graball: Ditto, but like matchall() rather than match(). We grab all the elements that match, and we can take an output delimiter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buff</td><td>Output buffer </td></tr>
    <tr><td class="paramname">bufc</td><td>Output buffer tracker </td></tr>
    <tr><td class="paramname">player</td><td>DBref of player </td></tr>
    <tr><td class="paramname">caller</td><td>DBref of caller </td></tr>
    <tr><td class="paramname">cause</td><td>DBref of cause </td></tr>
    <tr><td class="paramname">fargs</td><td>Function's arguments </td></tr>
    <tr><td class="paramname">nfargs</td><td>Number of function's arguments </td></tr>
    <tr><td class="paramname">cargs</td><td>Command's arguments </td></tr>
    <tr><td class="paramname">ncargs</td><td>Number of command's arguments </td></tr>
  </table>
  </dd>
</dl>
<p>Walk the wordstring, until we find the word we want.</p>

</div>
</div>
<a id="ae4cce78f64493c19f35a985278538515" name="ae4cce78f64493c19f35a985278538515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4cce78f64493c19f35a985278538515">&#9670;&#160;</a></span>fun_graball()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fun_graball </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buff</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>bufc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>player</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>caller</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>cause</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>fargs</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nfargs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>cargs</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ncargs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like grab with matchall() rather than match(). We grab all the elements that match, and we can take an output delimiter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buff</td><td>Output buffer </td></tr>
    <tr><td class="paramname">bufc</td><td>Output buffer tracker </td></tr>
    <tr><td class="paramname">player</td><td>DBref of player </td></tr>
    <tr><td class="paramname">caller</td><td>DBref of caller </td></tr>
    <tr><td class="paramname">cause</td><td>DBref of cause </td></tr>
    <tr><td class="paramname">fargs</td><td>Function's arguments </td></tr>
    <tr><td class="paramname">nfargs</td><td>Number of function's arguments </td></tr>
    <tr><td class="paramname">cargs</td><td>Command's arguments </td></tr>
    <tr><td class="paramname">ncargs</td><td>Number of command's arguments </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6ab3b3320aeedd69d373cb504f85c169" name="a6ab3b3320aeedd69d373cb504f85c169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ab3b3320aeedd69d373cb504f85c169">&#9670;&#160;</a></span>fun_group()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fun_group </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buff</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>bufc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>player</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>caller</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>cause</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>fargs</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nfargs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>cargs</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ncargs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort a list by numerical-size group, i.e., take every Nth element. Useful for passing to a column-type function where you want the list to go down rather than across, for instance. </p>
<p>group(&lt;list&gt;, &lt;number of groups&gt;, &lt;idelim&gt;, &lt;odelim&gt;, &lt;gdelim&gt;)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buff</td><td>Output buffer </td></tr>
    <tr><td class="paramname">bufc</td><td>Output buffer tracker </td></tr>
    <tr><td class="paramname">player</td><td>DBref of player </td></tr>
    <tr><td class="paramname">caller</td><td>DBref of caller </td></tr>
    <tr><td class="paramname">cause</td><td>DBref of cause </td></tr>
    <tr><td class="paramname">fargs</td><td>Function's arguments </td></tr>
    <tr><td class="paramname">nfargs</td><td>Number of function's arguments </td></tr>
    <tr><td class="paramname">cargs</td><td>Command's arguments </td></tr>
    <tr><td class="paramname">ncargs</td><td>Number of command's arguments </td></tr>
  </table>
  </dd>
</dl>
<p>Separator checking is weird in this, since we can delimit by group, too, as well as the element delimiter. The group delimiter defaults to the output delimiter.</p>
<p>Go do it, unless the group size doesn't make sense.</p>

</div>
</div>
<a id="ac8bda981b96f4c60217fe07cb39fb538" name="ac8bda981b96f4c60217fe07cb39fb538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8bda981b96f4c60217fe07cb39fb538">&#9670;&#160;</a></span>fun_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fun_index </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buff</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>bufc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>player</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>caller</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>cause</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>fargs</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nfargs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>cargs</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ncargs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract a substring between occurrences of a single-character separator. </p>
<p>Treats <code>fargs</code>[1] as a single-character delimiter (default space if empty), and returns the portion of <code>fargs</code>[0] starting at the <code>fargs</code>[2]-th field and ending before the <code>fargs</code>[3]-th delimiter. Leading spaces after the starting delimiter are skipped when the separator is space; trailing spaces before the ending delimiter are trimmed. If <code>start</code> or <code>end</code> is less than 1, or the start position is past the end of the string, returns an empty string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buff</td><td>Output buffer </td></tr>
    <tr><td class="paramname">bufc</td><td>Output buffer tracker </td></tr>
    <tr><td class="paramname">player</td><td>DBref of player (unused) </td></tr>
    <tr><td class="paramname">caller</td><td>DBref of caller (unused) </td></tr>
    <tr><td class="paramname">cause</td><td>DBref of cause (unused) </td></tr>
    <tr><td class="paramname">fargs</td><td>Function arguments: [0]=string, [1]=separator char (optional), [2]=start field (1-based), [3]=end field (1-based) </td></tr>
    <tr><td class="paramname">nfargs</td><td>Number of function arguments (unused) </td></tr>
    <tr><td class="paramname">cargs</td><td>Command arguments (unused) </td></tr>
    <tr><td class="paramname">ncargs</td><td>Number of command arguments (unused) </td></tr>
  </table>
  </dd>
</dl>
<p>move s to point to the start of the item we want</p>
<p>skip over just spaces</p>
<p>figure out where to end the string</p>
<p>if we've gotten this far, we've run off the end of the string</p>

</div>
</div>
<a id="ab6d17f57a6e06eb8565b180b66dbd1e0" name="ab6d17f57a6e06eb8565b180b66dbd1e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6d17f57a6e06eb8565b180b66dbd1e0">&#9670;&#160;</a></span>fun_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fun_insert </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buff</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>bufc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>player</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>caller</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>cause</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>fargs</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nfargs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>cargs</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ncargs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a single element into a delimited list. </p>
<p>Splits <code>fargs</code>[0] on the delimiter (default space) and inserts <code>fargs</code>[2] at 1-based position <code>fargs</code>[1]. When <code>pos</code> == 1 and the input list is empty, the new element becomes the list. If <code>pos</code> &lt; 1, the original list is returned unchanged. If <code>pos</code> is beyond the end, the element is appended. Delimiter validation errors are written to <code>buff</code> by the argument check.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buff</td><td>Output buffer </td></tr>
    <tr><td class="paramname">bufc</td><td>Output buffer tracker </td></tr>
    <tr><td class="paramname">player</td><td>DBref of player (unused) </td></tr>
    <tr><td class="paramname">caller</td><td>DBref of caller (unused) </td></tr>
    <tr><td class="paramname">cause</td><td>DBref of cause (unused) </td></tr>
    <tr><td class="paramname">fargs</td><td>Function arguments: [0]=list, [1]=position (1-based), [2]=text to insert, [3]=optional delimiter </td></tr>
    <tr><td class="paramname">nfargs</td><td>Number of function arguments </td></tr>
    <tr><td class="paramname">cargs</td><td>Command arguments (unused) </td></tr>
    <tr><td class="paramname">ncargs</td><td>Number of command arguments (unused) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0028782d1ebb7431ed155344055154fc" name="a0028782d1ebb7431ed155344055154fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0028782d1ebb7431ed155344055154fc">&#9670;&#160;</a></span>fun_itemize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fun_itemize </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buff</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>bufc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>player</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>caller</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>cause</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>fargs</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nfargs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>cargs</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ncargs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Turn a list into a punctuated list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buff</td><td>Output buffer </td></tr>
    <tr><td class="paramname">bufc</td><td>Output buffer tracker </td></tr>
    <tr><td class="paramname">player</td><td>DBref of player </td></tr>
    <tr><td class="paramname">caller</td><td>DBref of caller </td></tr>
    <tr><td class="paramname">cause</td><td>DBref of cause </td></tr>
    <tr><td class="paramname">fargs</td><td>Function's arguments </td></tr>
    <tr><td class="paramname">nfargs</td><td>Number of function's arguments </td></tr>
    <tr><td class="paramname">cargs</td><td>Command's arguments </td></tr>
    <tr><td class="paramname">ncargs</td><td>Number of command's arguments </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac18dc99ef6e585bd16d5fd590c887437" name="ac18dc99ef6e585bd16d5fd590c887437"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac18dc99ef6e585bd16d5fd590c887437">&#9670;&#160;</a></span>fun_last()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fun_last </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buff</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>bufc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>player</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>caller</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>cause</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>fargs</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nfargs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>cargs</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ncargs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the last word from a list while preserving ANSI state. </p>
<p>Trims leading separators, walks the list using the input delimiter (default space), and copies the final element to <code>buff</code>. For single-character delimiters, ANSI escape sequences are tracked so the color state active at the end of the list is reapplied before emitting the last token. For multi-character delimiters, the function scans from the end of the string to locate the final separator. With no arguments, returns an empty string without emitting an error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buff</td><td>Output buffer </td></tr>
    <tr><td class="paramname">bufc</td><td>Output buffer tracker </td></tr>
    <tr><td class="paramname">player</td><td>DBref of player (unused) </td></tr>
    <tr><td class="paramname">caller</td><td>DBref of caller (unused) </td></tr>
    <tr><td class="paramname">cause</td><td>DBref of cause (unused) </td></tr>
    <tr><td class="paramname">fargs</td><td>Function arguments: [0]=list, [1]=optional delimiter </td></tr>
    <tr><td class="paramname">nfargs</td><td>Number of function arguments </td></tr>
    <tr><td class="paramname">cargs</td><td>Command arguments (unused) </td></tr>
    <tr><td class="paramname">ncargs</td><td>Number of command arguments (unused) </td></tr>
  </table>
  </dd>
</dl>
<p>If we are passed an empty arglist return a null string</p>
<p>this is like <a class="el" href="fnhelper_8c.html#a344a6ca153a0edf3f414048b245d7d18" title="Point at start of next token in string.">next_token()</a>, but tracking ansi</p>
<p>Walk backwards through the string to find the separator. Find the last character, and compare the previous characters, to find the separator. If we can't find the last character or we know we're going to fall off the string, return the original string.</p>

</div>
</div>
<a id="a04877225af5d230c44bcccefa200fd3f" name="a04877225af5d230c44bcccefa200fd3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04877225af5d230c44bcccefa200fd3f">&#9670;&#160;</a></span>fun_ldelete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fun_ldelete </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buff</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>bufc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>player</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>caller</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>cause</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>fargs</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nfargs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>cargs</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ncargs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a single element from a delimited list. </p>
<p>Splits <code>fargs</code>[0] on the delimiter (default space) and drops the element at 1-based position <code>fargs</code>[1]. If <code>pos</code> &lt; 1, the original list is returned. If <code>pos</code> is beyond the end, the original list is returned unchanged. An empty input list yields an empty result. Delimiter validation errors are written to <code>buff</code> by the argument check.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buff</td><td>Output buffer </td></tr>
    <tr><td class="paramname">bufc</td><td>Output buffer tracker </td></tr>
    <tr><td class="paramname">player</td><td>DBref of player (unused) </td></tr>
    <tr><td class="paramname">caller</td><td>DBref of caller (unused) </td></tr>
    <tr><td class="paramname">cause</td><td>DBref of cause (unused) </td></tr>
    <tr><td class="paramname">fargs</td><td>Function arguments: [0]=list, [1]=position (1-based), [2]=optional delimiter </td></tr>
    <tr><td class="paramname">nfargs</td><td>Number of function arguments </td></tr>
    <tr><td class="paramname">cargs</td><td>Command arguments (unused) </td></tr>
    <tr><td class="paramname">ncargs</td><td>Number of command arguments (unused) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c4c0992e581bd64a8d2429fd6e40d9e" name="a0c4c0992e581bd64a8d2429fd6e40d9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c4c0992e581bd64a8d2429fd6e40d9e">&#9670;&#160;</a></span>fun_ledit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fun_ledit </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buff</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>bufc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>player</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>caller</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>cause</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>fargs</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nfargs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>cargs</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ncargs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If a &lt;word&gt; in </p><ul>
</ul>
<p>in &lt;old words&gt;, replace it with the corresponding word from &lt;new words&gt;. This is basically a mass-edit. This is an EXACT, not a case-insensitive or wildcarded, match. </p>
<p>ledit(&lt;list of words&gt;,&lt;old words&gt;,&lt;new words&gt;[,&lt;delim&gt;[,&lt;output delim&gt;]])</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buff</td><td>Output buffer </td></tr>
    <tr><td class="paramname">bufc</td><td>Output buffer tracker </td></tr>
    <tr><td class="paramname">player</td><td>DBref of player </td></tr>
    <tr><td class="paramname">caller</td><td>DBref of caller </td></tr>
    <tr><td class="paramname">cause</td><td>DBref of cause </td></tr>
    <tr><td class="paramname">fargs</td><td>Function's arguments </td></tr>
    <tr><td class="paramname">nfargs</td><td>Number of function's arguments </td></tr>
    <tr><td class="paramname">cargs</td><td>Command's arguments </td></tr>
    <tr><td class="paramname">ncargs</td><td>Number of command's arguments </td></tr>
  </table>
  </dd>
</dl>
<p>Iterate through the words.</p>
<p>If we specify more old words than we have new words, we assume we want to just nullify.</p>

</div>
</div>
<a id="a736bf9889f910975b364699bc77e9912" name="a736bf9889f910975b364699bc77e9912"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a736bf9889f910975b364699bc77e9912">&#9670;&#160;</a></span>fun_lrand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fun_lrand </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buff</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>bufc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>player</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>caller</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>cause</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>fargs</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nfargs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>cargs</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ncargs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a list of random integers within an inclusive range. </p>
<p>Produces <code>n_times</code> values between <code>r_bot</code> and <code>r_top</code> (inclusive), separated by the optional output delimiter. The count is clamped to LBUF_SIZE. When <code>r_top</code> == <code>r_bot</code>, the constant value repeats; when <code>r_top</code> &lt; <code>r_bot</code>, the call returns an empty string. A zero or negative <code>n_times</code> also yields an empty result.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buff</td><td>Output buffer </td></tr>
    <tr><td class="paramname">bufc</td><td>Output buffer tracker </td></tr>
    <tr><td class="paramname">player</td><td>DBref of player (unused) </td></tr>
    <tr><td class="paramname">caller</td><td>DBref of caller (unused) </td></tr>
    <tr><td class="paramname">cause</td><td>DBref of cause (unused) </td></tr>
    <tr><td class="paramname">fargs</td><td>Function arguments: [0]=lower bound, [1]=upper bound, [2]=count, [3]=optional delimiter </td></tr>
    <tr><td class="paramname">nfargs</td><td>Number of function arguments </td></tr>
    <tr><td class="paramname">cargs</td><td>Command arguments (unused) </td></tr>
    <tr><td class="paramname">ncargs</td><td>Number of command arguments (unused) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1376f7070128ad17612ce736b31222fc" name="a1376f7070128ad17612ce736b31222fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1376f7070128ad17612ce736b31222fc">&#9670;&#160;</a></span>fun_lreplace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fun_lreplace </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buff</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>bufc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>player</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>caller</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>cause</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>fargs</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nfargs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>cargs</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ncargs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace multiple positions in a list in one call. </p>
<p>Parses three lists: the source list <code>fargs</code>[0], replacement values <code>fargs</code>[1], and 1-based positions <code>fargs</code>[2]. The input delimiter (default space or <code>fargs</code>[3]) splits source and replacement lists; positions are always split on space. Output is joined with <code>fargs</code>[4] if provided, otherwise the input delimiter is reused. The replacement list and position list must contain the same number of elements or an error string is returned. Positions outside the source range are ignored. When no positions are supplied, the original list is returned unchanged. Delimiter validation errors are written to <code>buff</code> by the argument check.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buff</td><td>Output buffer </td></tr>
    <tr><td class="paramname">bufc</td><td>Output buffer tracker </td></tr>
    <tr><td class="paramname">player</td><td>DBref of player (unused) </td></tr>
    <tr><td class="paramname">caller</td><td>DBref of caller (unused) </td></tr>
    <tr><td class="paramname">cause</td><td>DBref of cause (unused) </td></tr>
    <tr><td class="paramname">fargs</td><td>Function arguments: [0]=source list, [1]=replacement list, [2]=positions list, [3]=optional input delimiter, [4]=optional output delimiter </td></tr>
    <tr><td class="paramname">nfargs</td><td>Number of function arguments </td></tr>
    <tr><td class="paramname">cargs</td><td>Command arguments (unused) </td></tr>
    <tr><td class="paramname">ncargs</td><td>Number of command arguments (unused) </td></tr>
  </table>
  </dd>
</dl>
<p>We're generous with the argument checking, in case the replacement list is blank, and/or the position list is blank.</p>
<p>If there are no positions to replace, then we just return the original list.</p>
<p>The number of elements we have in our replacement list must equal the number of elements in our position list.</p>
<p>Turn out lists into arrays for ease of manipulation.</p>
<p>The positions we have aren't necessarily sequential, so we can't just walk through the list. We have to replace position by position. If we get an invalid position number, just ignore it.</p>

</div>
</div>
<a id="a7bfd4fe1dadf8180ade01e9eb56fd2bf" name="a7bfd4fe1dadf8180ade01e9eb56fd2bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bfd4fe1dadf8180ade01e9eb56fd2bf">&#9670;&#160;</a></span>fun_match()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fun_match </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buff</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>bufc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>player</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>caller</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>cause</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>fargs</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nfargs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>cargs</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ncargs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the 1-based index of the first list element matching a pattern. </p>
<p>Trims leading separators, splits <code>fargs</code>[0] on the delimiter (default space if none provided), and compares each token to <code>fargs</code>[1] using wildcard matching (<code>quick_wild</code>). Returns the index of the first match, or 0 if no elements match. Argument validation errors are written to <code>buff</code> by the range and delimiter checks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buff</td><td>Output buffer </td></tr>
    <tr><td class="paramname">bufc</td><td>Output buffer tracker </td></tr>
    <tr><td class="paramname">player</td><td>DBref of player (unused) </td></tr>
    <tr><td class="paramname">caller</td><td>DBref of caller (unused) </td></tr>
    <tr><td class="paramname">cause</td><td>DBref of cause (unused) </td></tr>
    <tr><td class="paramname">fargs</td><td>Function arguments: [0]=list, [1]=pattern, [2]=optional delimiter </td></tr>
    <tr><td class="paramname">nfargs</td><td>Number of function arguments </td></tr>
    <tr><td class="paramname">cargs</td><td>Command arguments (unused) </td></tr>
    <tr><td class="paramname">ncargs</td><td>Number of command arguments (unused) </td></tr>
  </table>
  </dd>
</dl>
<p>Check each word individually, returning the word number of the first one that matches. If none match, return 0.</p>

</div>
</div>
<a id="a4070e7333d44adcaf479c9750ea8d2f6" name="a4070e7333d44adcaf479c9750ea8d2f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4070e7333d44adcaf479c9750ea8d2f6">&#9670;&#160;</a></span>fun_matchall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fun_matchall </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buff</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>bufc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>player</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>caller</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>cause</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>fargs</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nfargs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>cargs</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ncargs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the indices of all list elements that match (or don't match) a pattern. </p>
<p>Trims leading separators, splits <code>fargs</code>[0] on the input delimiter (default space), and tests each token against <code>fargs</code>[1] using wildcard matching (<code>quick_wild</code>). The IFELSE_FALSE flag (set by <code>unmatchall</code>) inverts the match test. Matching indices are joined with the output delimiter: if none is supplied, a space is used (even if the input delimiter differs). Returns an empty string when no elements qualify. Argument validation errors are written to <code>buff</code> by the range and delimiter checks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buff</td><td>Output buffer </td></tr>
    <tr><td class="paramname">bufc</td><td>Output buffer tracker </td></tr>
    <tr><td class="paramname">player</td><td>DBref of player (unused) </td></tr>
    <tr><td class="paramname">caller</td><td>DBref of caller (unused) </td></tr>
    <tr><td class="paramname">cause</td><td>DBref of cause (unused) </td></tr>
    <tr><td class="paramname">fargs</td><td>Function arguments: [0]=list, [1]=pattern, [2]=optional input delimiter, [3]=optional output delimiter </td></tr>
    <tr><td class="paramname">nfargs</td><td>Number of function arguments </td></tr>
    <tr><td class="paramname">cargs</td><td>Command arguments (unused) </td></tr>
    <tr><td class="paramname">ncargs</td><td>Number of command arguments (unused) </td></tr>
  </table>
  </dd>
</dl>
<p>SPECIAL CASE: If there's no output delimiter specified, we use a space, NOT the delimiter given for the list!</p>
<p>Check each word individually, returning the word number of all that match (or don't match, in the case of unmatchall). If none, return a null string.</p>

</div>
</div>
<a id="a4438048d237ee31a129f0f228a0ab800" name="a4438048d237ee31a129f0f228a0ab800"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4438048d237ee31a129f0f228a0ab800">&#9670;&#160;</a></span>fun_member()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fun_member </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buff</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>bufc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>player</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>caller</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>cause</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>fargs</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nfargs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>cargs</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ncargs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the 1-based position of a word in a delimited list. </p>
<p>Validates arguments and delimiter (default space). Trims leading separators then walks the list token by token. Returns the index of the first element equal to <code>fargs</code>[1], or "0" if the word does not occur. Delimiter validation errors are written to <code>buff</code> by the argument check.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buff</td><td>Output buffer </td></tr>
    <tr><td class="paramname">bufc</td><td>Output buffer tracker </td></tr>
    <tr><td class="paramname">player</td><td>DBref of player (unused) </td></tr>
    <tr><td class="paramname">caller</td><td>DBref of caller (unused) </td></tr>
    <tr><td class="paramname">cause</td><td>DBref of cause (unused) </td></tr>
    <tr><td class="paramname">fargs</td><td>Function arguments: [0]=list, [1]=word to find, [2]=optional delimiter </td></tr>
    <tr><td class="paramname">nfargs</td><td>Number of function arguments </td></tr>
    <tr><td class="paramname">cargs</td><td>Command arguments (unused) </td></tr>
    <tr><td class="paramname">ncargs</td><td>Number of command arguments (unused) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c3396bf0ae29ba67ad3c101e08603cb" name="a2c3396bf0ae29ba67ad3c101e08603cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c3396bf0ae29ba67ad3c101e08603cb">&#9670;&#160;</a></span>fun_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fun_remove </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buff</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>bufc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>player</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>caller</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>cause</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>fargs</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nfargs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>cargs</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ncargs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the first occurrence of a word from a delimited list. </p>
<p>Validates arguments and delimiter (default space). If the target word contains the delimiter, returns the error string "#-1 CAN ONLY DELETE ONE
ELEMENT". Walks the list token by token, copying all elements to <code>buff</code> except the first one that equals <code>fargs</code>[1]; subsequent matches are kept. If the word is not found, the original list is returned. An empty input list yields an empty result. Delimiter validation errors are written to <code>buff</code> by the argument check.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buff</td><td>Output buffer </td></tr>
    <tr><td class="paramname">bufc</td><td>Output buffer tracker </td></tr>
    <tr><td class="paramname">player</td><td>DBref of player (unused) </td></tr>
    <tr><td class="paramname">caller</td><td>DBref of caller (unused) </td></tr>
    <tr><td class="paramname">cause</td><td>DBref of cause (unused) </td></tr>
    <tr><td class="paramname">fargs</td><td>Function arguments: [0]=list, [1]=word to remove, [2]=optional delimiter </td></tr>
    <tr><td class="paramname">nfargs</td><td>Number of function arguments </td></tr>
    <tr><td class="paramname">cargs</td><td>Command arguments (unused) </td></tr>
    <tr><td class="paramname">ncargs</td><td>Number of command arguments (unused) </td></tr>
  </table>
  </dd>
</dl>
<p>Walk through the string copying words until (if ever) we get to one that matches the target word.</p>

</div>
</div>
<a id="ab8c32426bd8a9d20d39af91fb3dbf1d2" name="ab8c32426bd8a9d20d39af91fb3dbf1d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8c32426bd8a9d20d39af91fb3dbf1d2">&#9670;&#160;</a></span>fun_replace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fun_replace </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buff</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>bufc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>player</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>caller</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>cause</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>fargs</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nfargs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>cargs</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ncargs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace a single list element at a given position. </p>
<p>Splits <code>fargs</code>[0] on the delimiter (default space) and substitutes <code>fargs</code>[2] for the element at 1-based position <code>fargs</code>[1]. If <code>pos</code> &lt; 1, or <code>pos</code> is beyond the end of the list, the original list is returned unchanged. An empty input list yields an empty result. Delimiter validation errors are written to <code>buff</code> by the argument check.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buff</td><td>Output buffer </td></tr>
    <tr><td class="paramname">bufc</td><td>Output buffer tracker </td></tr>
    <tr><td class="paramname">player</td><td>DBref of player (unused) </td></tr>
    <tr><td class="paramname">caller</td><td>DBref of caller (unused) </td></tr>
    <tr><td class="paramname">cause</td><td>DBref of cause (unused) </td></tr>
    <tr><td class="paramname">fargs</td><td>Function arguments: [0]=list, [1]=position (1-based), [2]=replacement text, [3]=optional delimiter </td></tr>
    <tr><td class="paramname">nfargs</td><td>Number of function arguments </td></tr>
    <tr><td class="paramname">cargs</td><td>Command arguments (unused) </td></tr>
    <tr><td class="paramname">ncargs</td><td>Number of command arguments (unused) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a887cf465a532abdb1d34007750e673e1" name="a887cf465a532abdb1d34007750e673e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a887cf465a532abdb1d34007750e673e1">&#9670;&#160;</a></span>fun_rest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fun_rest </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buff</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>bufc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>player</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>caller</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>cause</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>fargs</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nfargs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>cargs</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ncargs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return all words except the first, preserving ANSI state. </p>
<p>Trims leading separators, consumes the first element (tracking ANSI escape sequences), then outputs any remaining text while restoring the active ANSI state so colors remain correct. With no arguments, returns an empty string without error output.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buff</td><td>Output buffer </td></tr>
    <tr><td class="paramname">bufc</td><td>Output buffer tracker </td></tr>
    <tr><td class="paramname">player</td><td>DBref of player (unused) </td></tr>
    <tr><td class="paramname">caller</td><td>DBref of caller (unused) </td></tr>
    <tr><td class="paramname">cause</td><td>DBref of cause (unused) </td></tr>
    <tr><td class="paramname">fargs</td><td>Function arguments: [0]=list, [1]=optional delimiter </td></tr>
    <tr><td class="paramname">nfargs</td><td>Number of function arguments </td></tr>
    <tr><td class="paramname">cargs</td><td>Command arguments (unused) </td></tr>
    <tr><td class="paramname">ncargs</td><td>Number of command arguments (unused) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1cb5b0169b9dc3315bcd9f9370802e33" name="a1cb5b0169b9dc3315bcd9f9370802e33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cb5b0169b9dc3315bcd9f9370802e33">&#9670;&#160;</a></span>fun_revwords()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fun_revwords </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buff</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>bufc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>player</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>caller</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>cause</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>fargs</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nfargs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>cargs</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ncargs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverse all elements in a delimited list. </p>
<p>Validates arguments and delimiter (default space). An empty argument list returns an empty result. Applies a bounds check to avoid overrunning the output buffer, truncating the input string if needed. Splits the list into an array with <code>fargs</code>[0] and writes elements in reverse order, reusing the input delimiter between items. Delimiter validation errors are written to <code>buff</code> by the argument check.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buff</td><td>Output buffer </td></tr>
    <tr><td class="paramname">bufc</td><td>Output buffer tracker </td></tr>
    <tr><td class="paramname">player</td><td>DBref of player (unused) </td></tr>
    <tr><td class="paramname">caller</td><td>DBref of caller (unused) </td></tr>
    <tr><td class="paramname">cause</td><td>DBref of cause (unused) </td></tr>
    <tr><td class="paramname">fargs</td><td>Function arguments: [0]=list, [1]=optional delimiter </td></tr>
    <tr><td class="paramname">nfargs</td><td>Number of function arguments </td></tr>
    <tr><td class="paramname">cargs</td><td>Command arguments (unused) </td></tr>
    <tr><td class="paramname">ncargs</td><td>Number of command arguments (unused) </td></tr>
  </table>
  </dd>
</dl>
<p>If we are passed an empty arglist return a null string</p>
<p>Nasty bounds checking</p>
<p>Chop it up into an array of words and reverse them.</p>

</div>
</div>
<a id="a0a364fff9001481b9ca0eca157f72001" name="a0a364fff9001481b9ca0eca157f72001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a364fff9001481b9ca0eca157f72001">&#9670;&#160;</a></span>fun_shuffle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fun_shuffle </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buff</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>bufc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>player</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>caller</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>cause</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>fargs</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nfargs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>cargs</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ncargs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>randomize order of words in a list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buff</td><td>Output buffer </td></tr>
    <tr><td class="paramname">bufc</td><td>Output buffer tracker </td></tr>
    <tr><td class="paramname">player</td><td>DBref of player </td></tr>
    <tr><td class="paramname">caller</td><td>DBref of caller </td></tr>
    <tr><td class="paramname">cause</td><td>DBref of cause </td></tr>
    <tr><td class="paramname">fargs</td><td>Function's arguments </td></tr>
    <tr><td class="paramname">nfargs</td><td>Number of function's arguments </td></tr>
    <tr><td class="paramname">cargs</td><td>Command's arguments </td></tr>
    <tr><td class="paramname">ncargs</td><td>Number of command's arguments </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4d5f84996e37d6b24287879e97154151" name="a4d5f84996e37d6b24287879e97154151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d5f84996e37d6b24287879e97154151">&#9670;&#160;</a></span>fun_sortby()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fun_sortby </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buff</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>bufc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>player</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>caller</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>cause</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>fargs</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nfargs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>cargs</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ncargs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort a list using a user-supplied comparison expression. </p>
<p>Sorts the list provided in <code>fargs</code>[1] using a user-defined comparison expression supplied either as an attribute name in <code>fargs</code>[0] or as a lambda string beginning with "#lambda/". The attribute text (or lambda body) is retrieved and passed as the comparison buffer to <code><a class="el" href="#a4fcf885c29460d3bbbf1b5fcd6ebe37a" title="Andrew Molitor&#39;s quicksort variant tolerant of non-transitive comparators.">sane_qsort()</a></code> via the <code><a class="el" href="#a831421e18f2c95ee645246f4f1fb8084" title="Invoke a user-provided comparison expression for sorting.">u_comp()</a></code> wrapper. The user expression will be evaluated with the two elements under comparison bound as the evaluation arguments; it must return a numeric result interpreted as negative if the first element is less than the second, zero if equal, and positive if greater.</p>
<p>Argument validation and delimiter handling are performed via <code><a class="el" href="#ac58586c2f7a343dcc079d3c06e3c771d" title="Validate function arguments and delimiter for list functions.">validate_list_args()</a></code> and <code><a class="el" href="fnhelper_8c.html#a342a3517e85b22bc13ce01d775aae8aa" title="Obtain delimiter.">delim_check()</a></code>; any error messages are written into <code>buff</code> and the function returns early. The input list is split using the input delimiter (default space) and the sorted result is written back to the output buffer joined with the output delimiter (or input delimiter when the output delimiter is not provided).</p>
<p>Resource notes:</p><ul>
<li>The attribute text (or lambda body) is copied into a temporary buffer and freed before returning.</li>
<li>Sorting uses <code><a class="el" href="#a4fcf885c29460d3bbbf1b5fcd6ebe37a" title="Andrew Molitor&#39;s quicksort variant tolerant of non-transitive comparators.">sane_qsort()</a></code> which swaps pointer values in-place; the elements pointed to must remain valid during the call.</li>
<li>The comparator evaluation respects function invocation and nesting limits; excessive usage may cause the comparator to return 0.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buff</td><td>Output buffer where the sorted list or error is written </td></tr>
    <tr><td class="paramname">bufc</td><td>Output buffer cursor for appending </td></tr>
    <tr><td class="paramname">player</td><td>DBref of the player invoking the function </td></tr>
    <tr><td class="paramname">caller</td><td>DBref of the caller (unused) </td></tr>
    <tr><td class="paramname">cause</td><td>DBref of the cause (unused) </td></tr>
    <tr><td class="paramname">fargs</td><td>Function arguments: [0]=attribute name or "#lambda/..." comparator, [1]=list to sort, [2]=optional input delimiter, [3]=optional output delimiter </td></tr>
    <tr><td class="paramname">nfargs</td><td>Number of function arguments in <code>fargs</code> </td></tr>
    <tr><td class="paramname">cargs</td><td>Command arguments (unused) </td></tr>
    <tr><td class="paramname">ncargs</td><td>Number of command arguments (unused) </td></tr>
  </table>
  </dd>
</dl>
<p>pointless to sort less than 2 elements</p>

</div>
</div>
<a id="a9f9bbb01fd4f57b73230da86d8790d43" name="a9f9bbb01fd4f57b73230da86d8790d43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f9bbb01fd4f57b73230da86d8790d43">&#9670;&#160;</a></span>fun_splice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fun_splice </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buff</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>bufc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>player</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>caller</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>cause</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>fargs</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nfargs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>cargs</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ncargs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge two lists by substituting matching elements from a second list. </p>
<p>Validates arguments and delimiter (default space). Requires that <code>fargs</code>[0] and <code>fargs</code>[1] have the same number of elements; otherwise returns "#-1 NUMBER OF WORDS MUST BE EQUAL". If <code>fargs</code>[2] contains more than one word, returns "#-1 TOO MANY WORDS". Uses <code>fargs</code>[2] as the match token: for each position, if the element from list1 equals that token, the element from the same position in list2 is emitted; otherwise the original element from list1 is emitted. Output uses <code>fargs</code>[4] when provided, else reuses the input delimiter. Delimiter validation errors are written to <code>buff</code> by the argument checks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buff</td><td>Output buffer </td></tr>
    <tr><td class="paramname">bufc</td><td>Output buffer tracker </td></tr>
    <tr><td class="paramname">player</td><td>DBref of player (unused) </td></tr>
    <tr><td class="paramname">caller</td><td>DBref of caller (unused) </td></tr>
    <tr><td class="paramname">cause</td><td>DBref of cause (unused) </td></tr>
    <tr><td class="paramname">fargs</td><td>Function arguments: [0]=list1, [1]=list2, [2]=match word, [3]=optional input delimiter, [4]=optional output delimiter </td></tr>
    <tr><td class="paramname">nfargs</td><td>Number of function arguments </td></tr>
    <tr><td class="paramname">cargs</td><td>Command arguments (unused) </td></tr>
    <tr><td class="paramname">ncargs</td><td>Number of command arguments (unused) </td></tr>
  </table>
  </dd>
</dl>
<p>length checks</p>
<p>loop through the two lists</p>
<p>&lt; replace</p>
<p>&lt; copy</p>

</div>
</div>
<a id="ad83c666b9ec5aca8f4d0cd35a21c6bb9" name="ad83c666b9ec5aca8f4d0cd35a21c6bb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad83c666b9ec5aca8f4d0cd35a21c6bb9">&#9670;&#160;</a></span>fun_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fun_table </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buff</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>bufc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>player</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>caller</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>cause</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>fargs</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nfargs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>cargs</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ncargs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Turn a list into a table. </p>
<p>table(&lt;list&gt;,&lt;field width&gt;,&lt;line length&gt;,&lt;list delim&gt;,&lt;field sep&gt;,&lt;pad&gt;) Only the </p><ul>
</ul>
<p>is mandatory. tables(&lt;list&gt;,&lt;field widths&gt;,&lt;lead str&gt;,&lt;trail str&gt;,&lt;list delim&gt;,&lt;field sep str&gt;,&lt;pad&gt;) Only the </p><ul>
</ul>
<p>&lt;field widths&gt; parameters are mandatory.</p>
<p>There are a couple of PennMUSH incompatibilities. The handling here is more complex and probably more desirable behavior. The issues are:</p><ul>
<li>ANSI states are preserved even if a word is truncated. Thus, the next word will start with the correct color.</li>
<li>ANSI does not bleed into the padding or field separators.</li>
<li>Having a 'r' embedded in the list will start a new set of columns. This allows a series of r-separated lists to be table-ified correctly, and doesn't mess up the character count.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buff</td><td>Output buffer </td></tr>
    <tr><td class="paramname">bufc</td><td>Output buffer tracker </td></tr>
    <tr><td class="paramname">player</td><td>DBref of player </td></tr>
    <tr><td class="paramname">caller</td><td>DBref of caller </td></tr>
    <tr><td class="paramname">cause</td><td>DBref of cause </td></tr>
    <tr><td class="paramname">fargs</td><td>Function's arguments </td></tr>
    <tr><td class="paramname">nfargs</td><td>Number of function's arguments </td></tr>
    <tr><td class="paramname">cargs</td><td>Command's arguments </td></tr>
    <tr><td class="paramname">ncargs</td><td>Number of command's arguments </td></tr>
  </table>
  </dd>
</dl>
<p>Get line length and column width. All columns are the same width. Calculate what we need to.</p>

</div>
</div>
<a id="aa76fe7cff1d8dded21d52750c80e8d75" name="aa76fe7cff1d8dded21d52750c80e8d75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa76fe7cff1d8dded21d52750c80e8d75">&#9670;&#160;</a></span>fun_tokens()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fun_tokens </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buff</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>bufc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>player</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>caller</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>cause</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>fargs</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nfargs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>cargs</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ncargs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a string such as 'this "Joe Bloggs" John' and turn it into an output delim-separated list. </p>
<p>tokens(&lt;string&gt;[,&lt;obj&gt;/&lt;attr&gt;][,&lt;open&gt;][,&lt;close&gt;][,&lt;sep&gt;][,&lt;osep&gt;])</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buff</td><td>Output buffer </td></tr>
    <tr><td class="paramname">bufc</td><td>Output buffer tracker </td></tr>
    <tr><td class="paramname">player</td><td>DBref of player </td></tr>
    <tr><td class="paramname">caller</td><td>DBref of caller </td></tr>
    <tr><td class="paramname">cause</td><td>DBref of cause </td></tr>
    <tr><td class="paramname">fargs</td><td>Function's arguments </td></tr>
    <tr><td class="paramname">nfargs</td><td>Number of function's arguments </td></tr>
    <tr><td class="paramname">cargs</td><td>Command's arguments </td></tr>
    <tr><td class="paramname">ncargs</td><td>Number of command's arguments </td></tr>
  </table>
  </dd>
</dl>
<p>Now we're inside quotes. Find the end quote, and copy the token inside of it. If we run off the end of the string, we ignore the literal opening marker that we've skipped.</p>
<p>We are at a bare word. Split it off.</p>
<p>Pass the token through the transformation function if we have one, or just copy it, if not.</p>
<p>Skip to start of next token, ignoring input separators.</p>

</div>
</div>
<a id="a399d38cc7ec52c373af6f5eaa58a4f0a" name="a399d38cc7ec52c373af6f5eaa58a4f0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a399d38cc7ec52c373af6f5eaa58a4f0a">&#9670;&#160;</a></span>fun_words()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fun_words </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buff</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>bufc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>player</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>caller</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>cause</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>fargs</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nfargs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>cargs</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ncargs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count the words in a list using the specified delimiter. </p>
<p>Trims leading separators, splits <code>fargs</code>[0] on the delimiter (default space when none provided), and writes the resulting count to <code>buff</code>. A missing argument returns 0 without error output.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buff</td><td>Output buffer </td></tr>
    <tr><td class="paramname">bufc</td><td>Output buffer tracker </td></tr>
    <tr><td class="paramname">player</td><td>DBref of player (unused) </td></tr>
    <tr><td class="paramname">caller</td><td>DBref of caller (unused) </td></tr>
    <tr><td class="paramname">cause</td><td>DBref of cause (unused) </td></tr>
    <tr><td class="paramname">fargs</td><td>Function arguments: [0]=list, [1]=optional delimiter </td></tr>
    <tr><td class="paramname">nfargs</td><td>Number of function arguments </td></tr>
    <tr><td class="paramname">cargs</td><td>Command arguments (unused) </td></tr>
    <tr><td class="paramname">ncargs</td><td>Number of command arguments (unused) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abc4a52e02b81762854b85c67bbfa0801" name="abc4a52e02b81762854b85c67bbfa0801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc4a52e02b81762854b85c67bbfa0801">&#9670;&#160;</a></span>get_list_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int get_list_type </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>fargs</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nfargs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>type_pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>ptrs</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nitems</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detect the list type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fargs</td><td>Function Arguments </td></tr>
    <tr><td class="paramname">nfargs</td><td>Number of arguments </td></tr>
    <tr><td class="paramname">type_pos</td><td>Which argument hold the list type </td></tr>
    <tr><td class="paramname">ptrs</td><td>List </td></tr>
    <tr><td class="paramname">nitems</td><td>Number of items in the list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int List type (NUMERIC_LIST, FLOAT_LIST, DBREF_LIST, ALPHANUM_LIST, or NOCASE_LIST)</dd></dl>
<p>If type_pos is within bounds, uses the specified type from fargs[type_pos-1]: 'd' for DBREF_LIST, 'n' for NUMERIC_LIST, 'f' for FLOAT_LIST, 'i' for NOCASE_LIST. Otherwise, auto-detects based on the list content. </p>

</div>
</div>
<a id="a17d4796833018312b3f2ce96fb9f7097" name="a17d4796833018312b3f2ce96fb9f7097"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17d4796833018312b3f2ce96fb9f7097">&#9670;&#160;</a></span>handle_sets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void handle_sets </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buff</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>bufc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>player</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>caller</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>cause</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>fargs</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nfargs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>cargs</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ncargs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This conversion is inefficient, since it's already happened once in <a class="el" href="#a0b49c23eb04930a3813cd6cdd7f92bba" title="Sort a list of strings by the requested type and optionally return positions.">do_asort()</a>.</p>
<p>&lt; Copy elements common to both lists</p>
<p>Handle case of two identical single-element lists</p>
<p>Process until one list is empty</p>
<p>Skip over duplicates</p>
<p>Compare and copy</p>
<p>Copy rest of remaining list, stripping duplicates</p>
<p>&lt; Copy elements not in both lists</p>
<p>Got a match, copy it</p>
<p>&lt; Copy elements unique to list1</p>
<p>Got a match, increment pointers</p>
<p>Item in list1 not in list2, copy</p>
<p>Item in list2 but not in list1, discard</p>
<p>Copy remainder of list1</p>

</div>
</div>
<a id="a725d1511b90dbc467db350295fcc4f84" name="a725d1511b90dbc467db350295fcc4f84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a725d1511b90dbc467db350295fcc4f84">&#9670;&#160;</a></span>handle_sort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void handle_sort </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buff</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>bufc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>player</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>caller</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>cause</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>fargs</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nfargs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>cargs</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ncargs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Entry point for the <code>sort()</code> family of functions. </p>
<p>Validates the function arguments and delimiters, converts the input list (from <code>fargs[0]</code>) into an array, determines the requested sort type via <code><a class="el" href="#abc4a52e02b81762854b85c67bbfa0801" title="Detect the list type.">get_list_type()</a></code>, and delegates the actual sorting to <code><a class="el" href="#a0b49c23eb04930a3813cd6cdd7f92bba" title="Sort a list of strings by the requested type and optionally return positions.">do_asort()</a></code>.</p>
<p>Behavior:</p><ul>
<li>If the caller requested positions (via the function mask <code>SORT_POS</code>), this function emits a space-separated list of 1-based positions corresponding to the sorted order (the positions array is produced by <code><a class="el" href="#a0b49c23eb04930a3813cd6cdd7f92bba" title="Sort a list of strings by the requested type and optionally return positions.">do_asort()</a></code> and freed after use).</li>
<li>Otherwise, it reconstructs the sorted array back into a delimited string using the output delimiter (or the input delimiter when unspecified) and writes that to the output buffer.</li>
</ul>
<p>The function returns early for empty argument lists. Delimiter validation and error reporting are handled by <code><a class="el" href="#ac58586c2f7a343dcc079d3c06e3c771d" title="Validate function arguments and delimiter for list functions.">validate_list_args()</a></code> and <code><a class="el" href="fnhelper_8c.html#a342a3517e85b22bc13ce01d775aae8aa" title="Obtain delimiter.">delim_check()</a></code>; any error messages are written into <code>buff</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buff</td><td>Output buffer where results or error strings are written </td></tr>
    <tr><td class="paramname">bufc</td><td>Pointer into <code>buff</code> for appending output </td></tr>
    <tr><td class="paramname">player</td><td>DBref of player invoking the function (unused by sorting) </td></tr>
    <tr><td class="paramname">caller</td><td>DBref of the caller (unused by sorting) </td></tr>
    <tr><td class="paramname">cause</td><td>DBref of the cause (unused by sorting) </td></tr>
    <tr><td class="paramname">fargs</td><td>Function arguments: at minimum [0]=list; additional args control sort type and delimiters as accepted by <code><a class="el" href="#abc4a52e02b81762854b85c67bbfa0801" title="Detect the list type.">get_list_type()</a></code> and the surrounding <code>sort()</code> API. </td></tr>
    <tr><td class="paramname">nfargs</td><td>Number of function arguments in <code>fargs</code> </td></tr>
    <tr><td class="paramname">cargs</td><td>Command arguments (unused) </td></tr>
    <tr><td class="paramname">ncargs</td><td>Number of command arguments (unused) </td></tr>
  </table>
  </dd>
</dl>
<p>If we are passed an empty arglist return a null string</p>
<p>Convert the list to an array</p>

</div>
</div>
<a id="a91f1c5ae9190768259bd48aba1331078" name="a91f1c5ae9190768259bd48aba1331078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91f1c5ae9190768259bd48aba1331078">&#9670;&#160;</a></span>i_comp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int i_comp </td>
          <td>(</td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>s1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>s2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>qsort helper for integer record comparison. </p>
<p>Interprets <code>s1</code> and <code>s2</code> as pointers to <code>I_RECORD</code> and compares their <code>data</code> fields as integers. Returns 1 when the first value is greater, -1 when smaller, and 0 when equal. Intended for use with <code>qsort</code> over arrays of <code>I_RECORD</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>Pointer to first <code>I_RECORD</code> </td></tr>
    <tr><td class="paramname">s2</td><td>Pointer to second <code>I_RECORD</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 1 if <code>s1-&gt;data</code> &gt; <code>s2-&gt;data</code>, -1 if less, 0 if equal </dd></dl>

</div>
</div>
<a id="a6f788e9a229c89a36b693b40cf72a858" name="a6f788e9a229c89a36b693b40cf72a858"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f788e9a229c89a36b693b40cf72a858">&#9670;&#160;</a></span>perform_tables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void perform_tables </td>
          <td>(</td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>player</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>list</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n_cols</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col_widths</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>lead_str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>trail_str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdelim.html">Delim</a> *</td>          <td class="paramname"><span class="paramname"><em>list_sep</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdelim.html">Delim</a> *</td>          <td class="paramname"><span class="paramname"><em>field_sep</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdelim.html">Delim</a> *</td>          <td class="paramname"><span class="paramname"><em>pad_char</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buff</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>bufc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>just</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw a table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">player</td><td>DBref of player (unused) </td></tr>
    <tr><td class="paramname">list</td><td>List to draw in table </td></tr>
    <tr><td class="paramname">n_cols</td><td>Number of columns </td></tr>
    <tr><td class="paramname">col_widths</td><td>Array of column widths </td></tr>
    <tr><td class="paramname">lead_str</td><td>Leading string for each row </td></tr>
    <tr><td class="paramname">trail_str</td><td>Trailing string for each row </td></tr>
    <tr><td class="paramname">list_sep</td><td>Separator between list items </td></tr>
    <tr><td class="paramname">field_sep</td><td>Separator between fields in items </td></tr>
    <tr><td class="paramname">pad_char</td><td>Padding character </td></tr>
    <tr><td class="paramname">buff</td><td>Output buffer </td></tr>
    <tr><td class="paramname">bufc</td><td>Output buffer tracker </td></tr>
    <tr><td class="paramname">just</td><td>Justification flag for the table</td></tr>
  </table>
  </dd>
</dl>
<p>Formats the input list into a multi-column table with specified widths and separators. </p>
<p>&lt; must skip '<br  />
' too</p>

</div>
</div>
<a id="afe771c8fccab772353340ae9fe3f9b19" name="afe771c8fccab772353340ae9fe3f9b19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe771c8fccab772353340ae9fe3f9b19">&#9670;&#160;</a></span>process_tables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void process_tables </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buff</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>bufc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>player</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>caller</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>cause</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>fargs</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nfargs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>cargs</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ncargs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validate that we have everything to draw the table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buff</td><td>Output buffer </td></tr>
    <tr><td class="paramname">bufc</td><td>Output buffer tracker </td></tr>
    <tr><td class="paramname">player</td><td>DBref of player </td></tr>
    <tr><td class="paramname">caller</td><td>DBref of caller </td></tr>
    <tr><td class="paramname">cause</td><td>DBref of cause </td></tr>
    <tr><td class="paramname">fargs</td><td>Function's arguments: [0]=list, [1]=column specs, [2]=optional delimiters </td></tr>
    <tr><td class="paramname">nfargs</td><td>Number of function's arguments </td></tr>
    <tr><td class="paramname">cargs</td><td>Command's arguments </td></tr>
    <tr><td class="paramname">ncargs</td><td>Number of command's arguments</td></tr>
  </table>
  </dd>
</dl>
<p>Parses column specifications and calls perform_tables to format the table. </p>

</div>
</div>
<a id="a4fcf885c29460d3bbbf1b5fcd6ebe37a" name="a4fcf885c29460d3bbbf1b5fcd6ebe37a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fcf885c29460d3bbbf1b5fcd6ebe37a">&#9670;&#160;</a></span>sane_qsort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sane_qsort </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>array</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>left</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>right</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*</td>          <td class="paramname"><span class="paramname"><em>compare&#160;</em></span>)(const void *, const void *, char *, dbref, dbref, dbref), </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>cbuff</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>thing</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>player</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>cause</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Andrew Molitor's quicksort variant tolerant of non-transitive comparators. </p>
<p>This routine sorts an array of pointers in-place using a randomized pivot-based partitioning algorithm that does not require the comparator to satisfy strict transitivity. It is intended for use when the comparison function may depend on external context and therefore can produce comparisons that violate a&gt;b =&gt; b&lt;a. The algorithm partitions elements around a pivot chosen at random, swaps pointers in-place, and recursively sorts partitions. Tail recursion is converted to iteration to reduce stack usage.</p>
<p>Comparator contract:</p><ul>
<li>The provided <code>compare</code> callback must have the signature <code>int compare(const void *a, const void *b, char *cbuff, dbref, dbref, dbref)</code> and should return negative if <code>a &lt; b</code>, zero if <code>a == b</code>, positive if <code>a &gt; b</code> (semantics are determined by the caller-provided comparator).</li>
<li>The additional parameters <code>cbuff</code>, <code>thing</code>, <code>player</code>, and <code>cause</code> are forwarded to <code>compare</code> unchanged and may be used by user-defined comparison expressions.</li>
</ul>
<p>Notes and limitations:</p><ul>
<li>Sorting is performed by swapping <code>void *</code> pointers; element data is not copied. The caller is responsible for pointer validity for the duration of the call.</li>
<li>The routine is not inherently thread-safe; concurrent calls must ensure the comparator and context are safe for parallel use.</li>
<li>Average complexity is O(n log n); worst-case is O(n^2), but randomized pivot selection reduces the likelihood of adversarial worst-cases.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Array of pointers to sort (modified in-place) </td></tr>
    <tr><td class="paramname">left</td><td>Index of the leftmost element to sort (0-based) </td></tr>
    <tr><td class="paramname">right</td><td>Index of the rightmost element to sort (0-based) </td></tr>
    <tr><td class="paramname">compare</td><td>Function pointer to comparator with extended context </td></tr>
    <tr><td class="paramname">cbuff</td><td>User-supplied comparison buffer (forwarded to <code>compare</code>) </td></tr>
    <tr><td class="paramname">thing</td><td>DBref passed to <code>compare</code> as context </td></tr>
    <tr><td class="paramname">player</td><td>DBref passed to <code>compare</code> as context </td></tr>
    <tr><td class="paramname">cause</td><td>DBref passed to <code>compare</code> as context </td></tr>
  </table>
  </dd>
</dl>
<p>Pick something at random at swap it into the leftmost slot This is the pivot, we'll put it back in the right spot later</p>
<p>Walk the array, looking for stuff that's less than our pivot. If it is, swap it with the next thing along</p>
<p>Now we put the pivot back, it's now in the right spot, we never need to look at it again, trust me.</p>
<p>At this point everything underneath the 'last' index is &lt; the entry at 'last' and everything above it is not &lt; it.</p>

</div>
</div>
<a id="a3e1023fafb1c56822364d806974b4a1d" name="a3e1023fafb1c56822364d806974b4a1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e1023fafb1c56822364d806974b4a1d">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>q</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>swaps two points to strings </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>First points to strings </td></tr>
    <tr><td class="paramname">q</td><td>Second points to strings </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad6e7f7ec7db9654cb135bc77e8f93a19" name="ad6e7f7ec7db9654cb135bc77e8f93a19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6e7f7ec7db9654cb135bc77e8f93a19">&#9670;&#160;</a></span>tables_helper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tables_helper </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>list</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structColorState.html">ColorState</a> *</td>          <td class="paramname"><span class="paramname"><em>last_state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n_cols</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col_widths</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>lead_str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>trail_str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdelim.html">Delim</a> *</td>          <td class="paramname"><span class="paramname"><em>list_sep</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdelim.html">Delim</a> *</td>          <td class="paramname"><span class="paramname"><em>field_sep</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdelim.html">Delim</a> *</td>          <td class="paramname"><span class="paramname"><em>pad_char</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buff</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>bufc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>just</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function for perform_tables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>Input list to format into table </td></tr>
    <tr><td class="paramname">last_state</td><td>Current ANSI color state </td></tr>
    <tr><td class="paramname">n_cols</td><td>Number of columns in the table </td></tr>
    <tr><td class="paramname">col_widths</td><td>Array of column widths </td></tr>
    <tr><td class="paramname">lead_str</td><td>Leading string for each row </td></tr>
    <tr><td class="paramname">trail_str</td><td>Trailing string for each row </td></tr>
    <tr><td class="paramname">list_sep</td><td>Separator between list items </td></tr>
    <tr><td class="paramname">field_sep</td><td>Separator between fields in items </td></tr>
    <tr><td class="paramname">pad_char</td><td>Padding character for alignment </td></tr>
    <tr><td class="paramname">buff</td><td>Output buffer </td></tr>
    <tr><td class="paramname">bufc</td><td>Output buffer tracker </td></tr>
    <tr><td class="paramname">just</td><td>Justification flag</td></tr>
  </table>
  </dd>
</dl>
<p>Formats the list into a table with specified columns, preserving ANSI colors. </p>
<p>Split apart the list. We need to find the length of each de-ansified word, as well as keep track of the state of each word. Overly-long words eventually get truncated, but the correct ANSI state is preserved nonetheless.</p>
<p>Beginning of new line. Insert newline if this isn't the first thing we're writing. Write left margin, if appropriate.</p>
<p>Do each column in the line.</p>
<p>Write leading padding if we need it.</p>
<p>If we had a previous state, we have to write it.</p>
<p>Copy in the word.</p>
<p>Bleah. We have a string that's too long. Truncate it. Write an ANSI normal at the end at the end if we need one (we'll restore the correct ANSI code with the next word, if need be).</p>
<p>Writing trailing padding if we need it.</p>
<p>Insert the field separator if this isn't the last column AND this is not the very last word in the list.</p>
<p>If we didn't get enough columns to fill out a line, and this is the last line, then we have to pad it out.</p>
<p>Write the right margin.</p>
<p>Save the ANSI state of the last word.</p>
<p>Clean up.</p>

</div>
</div>
<a id="a831421e18f2c95ee645246f4f1fb8084" name="a831421e18f2c95ee645246f4f1fb8084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a831421e18f2c95ee645246f4f1fb8084">&#9670;&#160;</a></span>u_comp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int u_comp </td>
          <td>(</td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>s1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>s2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>cbuff</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>thing</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>player</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>cause</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoke a user-provided comparison expression for sorting. </p>
<p>Evaluates the expression in <code>cbuff</code> with <code>s1</code> and <code>s2</code> bound as the two input parameters. The expression is executed via <code><a class="el" href="eval_8c.html#aa8b1b12892bbf3fb39d1e11e646fdfb7" title="Evaluate an expression string in place, expanding substitutions and functions.">eval_expression_string()</a></code> and must yield a numeric result interpreted as follows: negative if <code>s1 &lt; s2</code>, zero if equal, positive if <code>s1 &gt; s2</code>.</p>
<p>Important: this function is designed to be used with the internal <code><a class="el" href="#a4fcf885c29460d3bbbf1b5fcd6ebe37a" title="Andrew Molitor&#39;s quicksort variant tolerant of non-transitive comparators.">sane_qsort()</a></code> routine (which accepts extra context parameters) and is NOT compatible with the standard library <code>qsort()</code> comparator signature.</p>
<p>Resource and safety notes:</p><ul>
<li>The function guards against excessive resource use by checking <code>mushstate.func_invk_ctr</code>, <code>mushstate.func_nest_lev</code> and <code><a class="el" href="macros_8h.html#a33a1cf2eebe67d66c38250e3d33cac89" title="Handling CPU time checking.">Too_Much_CPU()</a></code>; if limits are exceeded it returns 0 to avoid further evaluation.</li>
<li><code>cbuff</code> is copied into a temporary buffer before evaluation; no caller ownership changes are performed by this function.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>Pointer to the first element (passed to the user expression) </td></tr>
    <tr><td class="paramname">s2</td><td>Pointer to the second element (passed to the user expression) </td></tr>
    <tr><td class="paramname">cbuff</td><td>Null-terminated user comparison expression (copied internally) </td></tr>
    <tr><td class="paramname">thing</td><td>DBref used as evaluation context (e.g. attribute owner) </td></tr>
    <tr><td class="paramname">player</td><td>DBref of the player performing the evaluation </td></tr>
    <tr><td class="paramname">cause</td><td>DBref of the cause of the evaluation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int &lt;0 if `s1 &lt; s2`, 0 if equal, &gt;0 if <code>s1 &gt; s2</code> as produced by the expression </dd></dl>
<p>Note that this function is for use in conjunction with our own sane_qsort routine, NOT with the standard library qsort!</p>

</div>
</div>
<a id="ac58586c2f7a343dcc079d3c06e3c771d" name="ac58586c2f7a343dcc079d3c06e3c771d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac58586c2f7a343dcc079d3c06e3c771d">&#9670;&#160;</a></span>validate_list_args()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int validate_list_args </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>func_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buff</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>bufc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>player</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>caller</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dbref</td>          <td class="paramname"><span class="paramname"><em>cause</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>fargs</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nfargs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>cargs</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ncargs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>min_args</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>max_args</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>delim_pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>delim_flags</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdelim.html">Delim</a> *</td>          <td class="paramname"><span class="paramname"><em>isep</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validate function arguments and delimiter for list functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func_name</td><td>Name of the function (for error messages) </td></tr>
    <tr><td class="paramname">buff</td><td>Output buffer </td></tr>
    <tr><td class="paramname">bufc</td><td>Output buffer tracker </td></tr>
    <tr><td class="paramname">player</td><td>DBref of player </td></tr>
    <tr><td class="paramname">caller</td><td>DBref of caller </td></tr>
    <tr><td class="paramname">cause</td><td>DBref of cause </td></tr>
    <tr><td class="paramname">fargs</td><td>Function's arguments </td></tr>
    <tr><td class="paramname">nfargs</td><td>Number of function's arguments </td></tr>
    <tr><td class="paramname">cargs</td><td>Command's arguments </td></tr>
    <tr><td class="paramname">ncargs</td><td>Command's argument count </td></tr>
    <tr><td class="paramname">min_args</td><td>Minimum number of arguments </td></tr>
    <tr><td class="paramname">max_args</td><td>Maximum number of arguments </td></tr>
    <tr><td class="paramname">delim_pos</td><td>Position of delimiter argument (-1 if none, or uses 1-based index) </td></tr>
    <tr><td class="paramname">delim_flags</td><td>Delimiter flags (DELIM_STRING, etc.) </td></tr>
    <tr><td class="paramname">isep</td><td>Pointer to Delim structure to populate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 1 if valid, 0 if error (already printed to buff) </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
