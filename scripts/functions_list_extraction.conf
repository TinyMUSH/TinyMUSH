# List and extraction function tests
# Format: command | expected substring

# first() - Returns first element
think [first(This is a test)] | This
think [first(Would you like coffee, or perhaps tea)] | Would
think [first(List&with&nonstandard&delimiters,&)] | List
think [first(SingleWord)] | SingleWord

# rest() - Returns everything except first element
think [rest(This is a test)] | is a test
think [rest(Would you like coffee)] | you like coffee
think [rest(List!with!different!delimiters,!)] | with!different!delimiters
think [rest(SingleWord)] |

# last() - Returns last element
think [last(This is a test)] | test
think [last(Happy-Fun-Test-Thing,-)] | Thing
think [last(SingleWord)] | SingleWord

# extract() - Extract slice of elements
think [extract(This is a really neat example,4,2)] | really neat
think [extract(Another@funky@test@for@extract,3,3,@)] | test@for@extract
think [extract(Another@funky@test@for@extract,3,3,@,---)] | test---for---extract
think [extract(a b c d e f,2,3)] | b c d

# index() - Like extract but with custom separator
think index(Cup of Tea ~ Mug of Beer ~ Glass of Wine,~,2,1) | Mug of Beer
think index(First~Second~Third~Fourth,~,3,2) | Third~Fourth

# elements() - Get specific elements by position
think [elements(Foo Ack Beep Moo Zot,2 4)] | Ack Moo
think [elements(Foo Ack Beep Moo Zot,-2 -4)] | Moo Ack
think [elements(Foof~Ack~Beep~Moo,3 1,~)] | Beep~Foof
think [elements(Foof~Ack~Beep~Moo,3 1,~,-)] | Beep-Foof

# exclude() - Opposite of elements, exclude positions
think [exclude(Foo Ack Beep Moo Zot,2 4)] | Foo Beep Zot
think [exclude(Foo Ack Beep Moo Zot,-2 -4)] | Foo Beep Zot
think [exclude(Foof~Ack~Beep~Moo,3 1,~)] | Ack~Moo
think [exclude(Foof~Ack~Beep~Moo,3 1,~,-)] | Ack-Moo

# grab() - First match with wildcard pattern
think [grab(This is a new test,?e*)] | new
think [grab(Holodeck:#10~Airlock:#58~Dorm:#12~Brig:#83,Airlock:*,~)] | Airlock:#58
think [grab(apple banana cherry,b*)] | banana
think [grab(apple banana cherry,*e*)] | apple

# graball() - All matches with wildcard pattern
think [graball(This is a new test,?e*)] | new test
think [graball(Holodeck:#10~Airlock:#58~Dorm:#12~Brig:#83,*i*:*,~)] | Airlock:#58~Brig:#83
think [graball(apple banana cherry,*e*)] | apple cherry
think [graball(red green blue yellow,*e*, ,+)] | red+green+blue

# regrab() - First regex match (case-sensitive)
think [regrab(This is a new test,is)] | This
think [regrab(This is a new test,^is)] | is
think [regrab(apple Banana cherry,^B)] | Banana

# regrabi() - First regex match (case-insensitive)
&VREGEX me=^A.+:#[0-9]+ | Set.
think [regrabi(Holodeck:#10~Airlock:#58~Dorm:#12~Brig:#83,[v(VREGEX)],~)] | Airlock:#58
think [regrabi(apple Banana cherry,^banana)] | Banana

# regraball() - All regex matches (case-sensitive)
think [regraball(This is a new test,is)] | This is
think [regraball(apple Banana Cherry,^B)] | Banana
think [regraball(apple Banana Cherry,^C)] | Cherry

# regraballi() - All regex matches (case-insensitive)
&VREGEX2 me=^[A-Z].+:#1[0-9]+ | Set.
think [regraballi(Holodeck:#10~Airlock:#58~Dorm:#12~Brig:#83,[v(VREGEX2)],~,_)] | Holodeck:#10_Dorm:#12
think [regraballi(apple Banana cherry,^a)] | apple
think [regraballi(apple Banana cherry,^b)] | Banana

# choose() - Random weighted choice (just verify it returns something from the list)
think [choose(abc def ghi jkl,10 5 3 2)] |

# Cleanup test attributes
&VREGEX me
&VREGEX2 me
