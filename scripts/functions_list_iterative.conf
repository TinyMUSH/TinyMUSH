# List iterative/processing function tests
# Format: command | expected substring

# Setup helper attributes
&ADD_ONE me=add(%0,1)
&IS_ODD me=if(mod(%0,2),1,)
&ADD_NUMS me=add(%0,%1)
&REV_STR me=reverse(%0)
&COND_LEN me=strlen(%0)
&SORT_ALPHA me=sort(%0)
&ALWAYS_ONE me=1
&ALWAYS_EMPTY me=

# iter / iter2 basic iteration
think [iter(1 2 3,add(##,1))] | 2 3 4
think [iter2(1 2,10 20,add(##,#+))] | 11 22

# list / list2 line output (returns empty string but emits lines)
think [list(red blue,##:#@)] | red:1
think [list2(apple banana,10 20,##-#+-#@)] | banana-20-2

# loop legacy line output
think [loop(1 2 3,##/#@)] | 3/3

# ilev / itext / itext2 / inum inside nested iter
think [iter(X Y,iter(1 2,itext(0)-##))] | Y-2
think [iter(foo bar,inum(0))] | 1 2
think [iter2(alpha beta,gamma delta,itext2(ilev()))] | gamma delta

# ibreak stops further evaluation at current level
think [iter(A B C,iter(junk1 junk2,%i0:%i1 [ibreak(0)]))] | junk1:C

# map / filter / filterbool / fold
think [map(me/ADD_ONE,1 2 3 4)] | 2 3 4 5
think [filter(me/ALWAYS_ONE,1 2 3 4 5)] | 1 2 3 4 5
think [filterbool(me/ALWAYS_ONE,2-3-4-5-6,-,+)] | 2+3+4+5+6
think [filterbool(me/ALWAYS_EMPTY,7 8 9)] |
think [fold(me/ADD_NUMS,1 2 3 4 5)] | 15
think [fold(me/ADD_NUMS,2-4-6,0,-)] | 12

# istrue / isfalse inline filtering
think [istrue(1 2 3 4 5,##)] | 1 2 3 4 5
think [isfalse(1-2-3-4-5,,-,.)] |

# whentrue / whentrue2 stop when eval turns false
think [whentrue(1 2 0 2 1,##)] | 1 2 0
think [whentrue2(5 4 3 2 1,5 4 0 2 1,##-#+)] | 5-5 4-4 3-0

# whenfalse / whenfalse2 stop when eval turns true
think [whenfalse(0 0 1 2,##)] | 0
think [whenfalse2(1 1 2 2,1 1 0 2,##-#+)] | 1-1

# mix combines multiple lists element-wise
think [mix(me/ADD_NUMS,1 2 3,10 20 30)] | 11 22 33
think [mix(me/ADD_NUMS,1:3:5,2:4:6,:)] | 3:7:11

# step batches elements before applying function
think [step(me/ADD_NUMS,1 2 3 4,2)] | 3 7

# munge reorders second list based on transformed first list
think [munge(me/SORT_ALPHA,c b a,one two three)] | three two one

# splice merges two lists, replacing target word
think [splice(foo-bar-baz,eek-moo-gleep,bar,-,+)] | foo+moo+baz

# map-style while with termination condition function
think [while(me/REV_STR,me/COND_LEN,foo bar meep flibble baz,4)] | oof rab peem

# until over two lists with regexp termination
&UNTIL_EVAL me=[add(%0,%1)]
&UNTIL_COND me=[sub(%1,%0)]
think [until(me/UNTIL_EVAL,me/UNTIL_COND,0 1 2 3,4 2 1 0,-,,;)] | 4;3;3
