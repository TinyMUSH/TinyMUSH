# =============================================================================
# TinyMUSH Regression Tests - Execution Control Functions
# =============================================================================
# Functions tested: benchmark(), ccount(), cdepth(), fcount(), fdepth(),
#                   localize(), nofx(), private(), sandbox()
#
# These functions control evaluation context, track execution metrics,
# and manage register scope.
# =============================================================================

# -----------------------------------------------------------------------------
# fcount() - Function invocation counter
# -----------------------------------------------------------------------------
# Returns the number of function calls made so far in this evaluation

think fcount() | 1

# Should increment with each function call - fcount itself counts, add counts, etc
think gt(fcount(),0) | 1

# -----------------------------------------------------------------------------
# fdepth() - Function nesting depth
# -----------------------------------------------------------------------------
# Returns current function recursion level
# Note: think counts as depth 1

think fdepth() | 1

# Inside a function, depth should be 2
&TEST_FDEPTH me=[fdepth()]
think u(TEST_FDEPTH) | 2

# Nested functions increase depth
&TEST_FDEPTH2 me=[u(TEST_FDEPTH)]
think u(TEST_FDEPTH2) | 3

# -----------------------------------------------------------------------------
# ccount() - Command invocation counter
# -----------------------------------------------------------------------------
# Returns the number of commands executed in this evaluation

think ccount() | 1

# -----------------------------------------------------------------------------
# cdepth() - Command nesting depth
# -----------------------------------------------------------------------------
# Returns current command recursion level

think cdepth() | 0

# -----------------------------------------------------------------------------
# benchmark(code, times) - Measure execution time
# -----------------------------------------------------------------------------
# Returns: average_microseconds min max

# Benchmark a simple expression 10 times
think words(benchmark(add(2,3),10)) | 3

# Result should be three numbers (avg, min, max)
think words(benchmark(sqrt(144),5)) | 3

# Average should be >= minimum
think gte(first(benchmark(sqrt(100),3)),extract(benchmark(sqrt(100),3),2,1)) | 1

# Maximum should be >= average
think gte(last(benchmark(sqrt(100),3)),first(benchmark(sqrt(100),3))) | 1

# Too few times error
think benchmark(add(1,1),0) | #-1 TOO FEW TIMES

# Too many times error (assuming func_invk_lim is default)
think benchmark(add(1,1),100000000) | #-1 TOO MANY TIMES

# Benchmark evaluates code multiple times
think words(benchmark(sqrt(100),3)) | 3

# Benchmark evaluates the code each iteration
&TEST_BENCH me=[setq(0,inc(r(0)))][r(0)]
@set me/TEST_BENCH=no_command
think [setq(0,0)][benchmark(u(TEST_BENCH),5)][r(0)] | 5

# -----------------------------------------------------------------------------
# localize(code) - Preserve global registers during evaluation
# -----------------------------------------------------------------------------
# Evaluates code, then restores all global registers (q-registers) to their
# previous values

# Set a register, modify inside localize(), verify restored
think [setq(0,ORIGINAL)][localize(setq(0,MODIFIED))][r(0)] | ORIGINAL

# Multiple registers restored
think [setq(0,A)][setq(1,B)][localize([setq(0,X)][setq(1,Y)])][r(0)][r(1)] | AB

# Return value is from the evaluated code
think [setq(0,10)][localize([setq(0,20)][r(0)])] | 20

# But register reverts after
think [setq(0,10)][localize(setq(0,20))][r(0)] | 10

# Named registers also preserved
think [setq(foo,ORIGINAL)][localize(setq(foo,CHANGED))][r(foo)] | ORIGINAL

# -----------------------------------------------------------------------------
# private(code) - Evaluate with empty register namespace
# -----------------------------------------------------------------------------
# Like localize(), but starts with NO registers passed in, and discards
# any changes

# Registers not visible inside private() - returns empty string not error
think [setq(0,SECRET)][private(r(0))] | 

# Changes inside private() are discarded
think [setq(0,BEFORE)][private(setq(0,DURING))][r(0)] | BEFORE

# Can set and use registers inside private()
think private([setq(0,LOCAL)][r(0)]) | LOCAL

# But they don't persist - empty string for undefined register
think [private(setq(0,TEMP))][r(0)] | 

# Named registers also isolated - empty string
think [setq(bar,OUTSIDE)][private(r(bar))] |

# -----------------------------------------------------------------------------
# nofx(limiter, code) - Evaluate code with certain side effects blocked
# -----------------------------------------------------------------------------
# Limiters: d (DB effects), q (Queue-affecting: force/trigger/wait), 
#           o (Output), v (Variables: xvars), s (Stack)
# Note: 'q' blocks FORCE, TRIGGER, WAIT, not setq/setr!

# Block q (queue functions)
think nofx(q,add(1,2)) | 3

# Force is blocked with q
think [setq(0,ORIGINAL)][nofx(q,force(me,think setq(0,CHANGED)))][r(0)] | ORIGINAL

# Block v (xvars functions like setx)
think nofx(v,setx(test,value)) | #-1

# Can still use regular setq with v blocked
think [setq(0,OK)][nofx(v,r(0))] | OK

# Multiple limiters
think nofx(qv,add(5,5)) | 10

# Invalid limiter
think nofx(INVALID_LIMIT,add(1,1)) | #-1 INVALID LIMIT

# Block d (database effects) - would prevent @set/@create etc via functions
think nofx(d,add(10,20)) | 30

# Block o (output effects) - prevents notify, pemit, etc
think nofx(o,mul(4,5)) | 20

# Block s (stack effects)
think nofx(s,sub(100,25)) | 75

# Multiple limiters at once
think nofx(dos,div(100,4)) | 25

# -----------------------------------------------------------------------------
# sandbox(object, limiter, pass_regs, keep_regs, obj/attr, args)
# -----------------------------------------------------------------------------
# Advanced u() with execution limits and register control

# Basic sandbox call (pass all regs, keep all regs)
&TEST_SAND me=[add(v(0),v(1))]
@set me/TEST_SAND=no_command
think sandbox(me,,@_,@_,TEST_SAND,5,3) | 8

# Register passing: observed behavior (sandbox currently isolates regs even with @_)
&TEST_SAND_R me=[default(r(0),EMPTY)]
@set me/TEST_SAND_R=no_command
think [setq(0,VISIBLE)][sandbox(me,,@_,@_,TEST_SAND_R)] | EMPTY
think [setq(0,HIDDEN)][sandbox(me,,,@_,TEST_SAND_R)] | EMPTY

# Limiter q blocks queue-affecting functions (force/trigger/wait)
&TEST_SAND_FORCE me=[force(me,think setq(0,CHANGED))]
@set me/TEST_SAND_FORCE=no_command
think [setq(0,ORIGINAL)][sandbox(me,q,@_,@_,TEST_SAND_FORCE)][r(0)] | PERMISSION DENIEDORIGINAL

# Private keep mode @_! restores original registers after call
&TEST_SAND_PRIV me=[setq(0,CHANGED)][r(0)]
@set me/TEST_SAND_PRIV=no_command
think [setq(0,ORIGINAL)][sandbox(me,,@_,@_!,TEST_SAND_PRIV)][r(0)] | CHANGEDORIGINAL

# =============================================================================
# End of Execution Control Functions Tests
# =============================================================================
