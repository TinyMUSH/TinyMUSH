# TinyMUSH program execution tests
# Format: command | expected substring
# Blank lines and lines starting with # are ignored.
# If no expected substring is provided, any non-empty output counts as OK.

# Setup: Create test objects
@create TestObj | TestObj created
@create Counter | Counter created
@dig TestRoom | TestRoom created

# Test @dolist (list iteration)
@dolist 1 2 3=@pemit me=Number: ## | Number: 1
@dolist a b c=@emit Item: ## Position: #@ | Item: a

# Test @dolist with delimiter
@dolist/delimit , {one,two,three}=@pemit me=## | one

# Test @switch (conditional execution)
@switch 5=5,{@pemit me=Match!} | Match!
@switch test=foo,{@pemit me=No},test,{@pemit me=Yes} | Yes
@switch abc=*b*,{@pemit me=Wildcard match} | Wildcard match

# Test @trigger (invoke attribute)
@set TestObj=ACTION:@pemit me=Action triggered! | Set.
@trigger TestObj/ACTION | Triggered

# Test @trigger with parameters
@set TestObj=GREET:@pemit me=Hello %0! | Set.
@trigger TestObj/GREET=World | Triggered
think [get(TestObj/GREET)] | Hello %0!

# Test @force (make object execute command)
@force TestObj=say Forced speech | Forced speech

# Test @wait (delayed execution)
@wait 0=@pemit me=Immediate execution | Immediate execution

# Test @notify/@drain (semaphore operations)
@set Counter=SEMAPHORE:0 | Set.
@notify Counter

# Test @drain (clear semaphore queue)
@set Counter=SEMAPHORE2:0 | Set.
@drain Counter/SEMAPHORE2 | Drained

# Test @halt (stop execution)
@set TestObj=HALTED | Set.
@halt TestObj | queue entries removed

# Test @ps (show queue)
@ps | Totals

# Test @include (include attribute content)
@set TestObj=INCLUDE_ME:@pemit me=Included content | Set.
@include TestObj/INCLUDE_ME | Included content

# Test @verb (user-defined verb)
@set TestObj=VWHAT:You test the object. | Set.
@set TestObj=VOWHAT:tests the object. | Set.
@set TestObj=VAWHAT:@pemit me=Verb executed | Set.
@verb TestObj=me,VWHAT,default,VOWHAT,default,VAWHAT | You test the object

# Test use command (use object)
@set TestObj=USE:You use the test object. | Set.
@set TestObj=OUSE:uses the test object. | Set.
@set TestObj=AUSE:@pemit me=Object used | Set.
use TestObj | You use the test object

# Test @switch with default
@switch nomatch=foo,{@pemit me=No},bar,{@pemit me=No},{@pemit me=Default} | Default

# Test @dolist/notify
think Testing dolist notify | Testing dolist notify

# Test @trigger with $command format (it ignores the $command part)
@set TestObj=CMD:$test *:@pemit me=Command: %0 | Set.
@trigger TestObj/CMD=argument | Triggered

# Test @force with dbref syntax
#2 @pemit me=Forced via dbref | Forced via dbref

# Test @switch/first (only first match)
@switch abc=*a*,@pemit me=First,*c*,@pemit me=Second | First

# Test @switch/all (all matches)
@switch test=t*,{@pemit me=Match1},*t,{@pemit me=Match2} | Match1

# Test @end (control flow)
@set TestObj=ENDTEST:@pemit %#=Before; @end/break 1=@pemit %#=Ended; @pemit %#=After | Set.
@trigger/now TestObj/ENDTEST | Triggered.

# Test @redirect (puppet/trace/verbose output redirection)
@set TestObj=PUPPET | Set.
@redirect TestObj=Wizard | Redirected

# Test @program (program input mode - last, no further commands)
@set TestObj=PROGACT:@switch %0=done,{think Program done; @quitprogram %#},{think Program input: %0} | Set.
@program me=TestObj/PROGACT:Enter input | Enter input
